{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python-Template","text":"<p>Template for python projects.</p>"},{"location":"examples/","title":"Examples","text":"<p>Examples go here.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>quesadilla<ul> <li>dynmat</li> <li>supercells</li> <li>symmetries</li> <li>utils</li> </ul> </li> <li>tools<ul> <li>run_f2py</li> </ul> </li> </ul>"},{"location":"reference/quesadilla/","title":"quesadilla","text":""},{"location":"reference/quesadilla/dynmat/","title":"dynmat","text":""},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator","title":"<code>NondiagonalPhononCalculator(sc_gen, nd_phonons)</code>","text":"Source code in <code>quesadilla/dynmat.py</code> <pre><code>def __init__(self, sc_gen: SupercellGenerator, nd_phonons: list[Phonopy]):\n    self.sc_gen = sc_gen\n    self.nd_phonons = nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator.from_toml","title":"<code>from_toml(toml_file)</code>  <code>classmethod</code>","text":"<p>Create a NondiagonalPhononCalculator object from a toml file.</p> <p>Generally the toml file is called quesadilla.toml and will be in the same directory as the sc-i directories, each of which should contain a phonopy.yaml file THAT MUST INCLUDE THE FORCE CONSTANTS computed from this supercell.</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>Path</code> <p>Path to the toml file</p> required <p>Returns:</p> Type Description <p>A NondiagonalPhononCalculator object</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>@classmethod\ndef from_toml(cls, toml_file: Path):\n    \"\"\"\n    Create a NondiagonalPhononCalculator object from a toml file.\n\n    Generally the toml file is called quesadilla.toml and will be\n    in the same directory as the sc-i directories, each of which\n    should contain a phonopy.yaml file THAT MUST INCLUDE THE\n    FORCE CONSTANTS computed from this supercell.\n\n    Args:\n        toml_file: Path to the toml file\n\n    Returns:\n        A NondiagonalPhononCalculator object\n    \"\"\"\n    # TODO: move to CLI (maybe?)\n    sc_gen = SupercellGenerator.from_toml(toml_file)\n    root = os.path.dirname(toml_file)\n    nd_phonons = cls._parse_ndsc_phonons(root, sc_gen)\n\n    return cls(sc_gen, nd_phonons)\n</code></pre>"},{"location":"reference/quesadilla/supercells/","title":"supercells","text":""},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator","title":"<code>SupercellGenerator(atoms, grid, q_ibz=None, sc_matrices=None, sc_sizes=None, q_comm=None)</code>","text":"Source code in <code>quesadilla/supercells.py</code> <pre><code>def __init__(\n    self,\n    atoms: PhonopyAtoms,\n    grid: ArrayLike,\n    q_ibz: np.ndarray = None,\n    sc_matrices: np.ndarray = None,\n    sc_sizes: np.ndarray = None,\n    q_comm: list = None,\n):\n    # Setup primitive structure and supercell\n    grid = np.array(grid)\n    self.supercell = Supercell(atoms, np.diag(grid))\n    self.primitive = Primitive(self.supercell, np.diag(1 / grid))\n    # Setup BZ data\n    self.grid = grid\n    if q_ibz is None:\n        self.q_ibz = self.get_ibz()\n    else:\n        q_ibz = np.array(q_ibz)\n        q_ibz = q_ibz[np.lexsort(q_ibz.T)]\n        try:\n            assert np.allclose(q_ibz, self.get_ibz())\n        except AssertionError as e:\n            raise ValueError(\n                \"IBZ q-points passed do not match what we expect from the \"\n                \"structure's symmetry.\"\n            ) from e\n\n    # Setup supercell data\n    self.sc_matrices = np.array(sc_matrices) if sc_matrices is not None else None\n    self.sc_sizes = np.array(sc_sizes) if sc_sizes is not None else None\n    self.q_comm = q_comm\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.get_ibz","title":"<code>get_ibz()</code>","text":"<p>Gets the q points in a structures IBZ. The output is sorted for consistency.</p> <ul> <li>primitive: phonopy.structure.cells.Primitive     The input structure (primitive cell, assumed to be standardized).</li> <li>grid: array-like     The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).</li> </ul> <ul> <li>qpoints: numpy.ndarray     The q points in the IBZ (fractional coordinates, sorted).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def get_ibz(\n    self,\n) -&gt; np.ndarray:\n    \"\"\"\n    Gets the q points in a structures IBZ. The output is sorted for consistency.\n\n    Parameters:\n    - primitive: phonopy.structure.cells.Primitive\n        The input structure (primitive cell, assumed to be standardized).\n    - grid: array-like\n        The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).\n\n    Returns:\n    - qpoints: numpy.ndarray\n        The q points in the IBZ (fractional coordinates, sorted).\n    \"\"\"\n    grid = np.array(self.grid)\n    # Contruct the SPG-style cell tuple\n    # https://spglib.readthedocs.io/en/stable/python-interface.html#crystal-structure-cell\n    mapping = {\n        element: i + 1 for i, element in enumerate(set(self.primitive.symbols))\n    }\n    zs = [mapping[element] for element in self.primitive.symbols]\n    cell = (\n        tuple(map(tuple, self.primitive.cell.tolist())),\n        tuple(map(tuple, self.primitive.scaled_positions.tolist())),\n        tuple(zs),\n    )\n    # Get irr q-points\n    # TODO: cell = primitive.totuple()\n    mapping, all_qpoints = spglib.get_ir_reciprocal_mesh(\n        grid, cell, is_shift=np.zeros(3), symprec=1e-5\n    )\n    irr_qpoints = np.array([all_qpoints[idx] / grid for idx in np.unique(mapping)])\n\n    # Sort by (z, y, x) for consistency\n    return irr_qpoints[np.lexsort(irr_qpoints.T)]\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.to_toml","title":"<code>to_toml(output_file)</code>","text":"<p>Write the supercell data to a TOML file.</p> <ul> <li>output_file: str     The output file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def to_toml(self, output_file):\n    \"\"\"\n    Write the supercell data to a TOML file.\n\n    Parameters:\n    - output_file: str\n        The output file path.\n    \"\"\"\n    doc = tomlkit.document()\n    doc.add(\"primitive\", self._atoms_to_toml())\n    doc.add(\"brillouin_zone\", self._bz_to_toml())\n    doc.add(\"supercells\", self._supercells_to_toml())\n\n    with open(output_file, \"w\") as f:\n        f.write(doc.as_string())\n    print(f\"Supercells written to {output_file}\")\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.from_toml","title":"<code>from_toml(input_file)</code>  <code>classmethod</code>","text":"<p>Read the supercell data from a TOML file.</p> <ul> <li>input_file: str     The input file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>@classmethod\ndef from_toml(cls, input_file: str):\n    \"\"\"\n    Read the supercell data from a TOML file.\n\n    Parameters:\n    - input_file: str\n        The input file path.\n    \"\"\"\n\n    with open(input_file, \"rb\") as f:\n        data = tomli.load(f)\n\n    primitive = cls.atoms_from_toml(data[\"primitive\"])\n    bz = data[\"brillouin_zone\"]\n    grid = bz[\"grid\"]\n    irr_q = np.array(bz[\"irreducible_q\"])\n\n    if \"supercells\" in data:\n        supercells = data[\"supercells\"]\n        T_matrices = np.array([sc[\"matrix\"] for sc in supercells])\n        sc_size = np.array([sc[\"size\"] for sc in supercells])\n        comm_q = [np.array(sc[\"commensurate_q\"]) for sc in supercells]\n    else:\n        T_matrices = None\n        sc_size = None\n        comm_q = None\n    return cls(primitive, grid, irr_q, T_matrices, sc_size, comm_q)\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.atoms_from_toml","title":"<code>atoms_from_toml(data)</code>  <code>staticmethod</code>","text":"<p>Reconstructs a PhonopyAtoms object from TOML data.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>@staticmethod\ndef atoms_from_toml(data: dict) -&gt; PhonopyAtoms:\n    \"\"\"Reconstructs a PhonopyAtoms object from TOML data.\"\"\"\n    return PhonopyAtoms(\n        symbols=data[\"species\"],\n        scaled_positions=np.array(data[\"frac_coords\"]),\n        cell=np.array(data[\"lattice\"]),\n    )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.generate_supercells","title":"<code>generate_supercells(minkowski_reduce=True, minimize_supercells=False)</code>","text":"<p>Generate nondiagonal supercells commensurate with the IBZ.</p> <ul> <li>reduce: bool     Whether to Minkowski reduce the supercells (default: True, recommended).</li> <li>trim: bool     Whether to trim the supercells using ILP (default: False, broken).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def generate_supercells(\n    self, minkowski_reduce: bool = True, minimize_supercells: bool = False\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate nondiagonal supercells commensurate with the IBZ.\n\n    Parameters:\n    - reduce: bool\n        Whether to Minkowski reduce the supercells (default: True, recommended).\n    - trim: bool\n        Whether to trim the supercells using ILP (default: False, broken).\n    \"\"\"\n\n    self.sc_matrices = self._get_ndsc_matrices()\n    if minkowski_reduce:\n        self.sc_matrices = np.array(\n            [minkowski_reduce_sc(T, self.primitive.cell) for T in self.sc_matrices]\n        )\n\n    self.sc_sizes = np.array([np.linalg.det(T) for T in self.sc_matrices])\n    self.q_comm = [\n        np.array([q for q in self.q_ibz if np.allclose(np.rint(T @ q), T @ q)])\n        for T in self.sc_matrices\n    ]\n\n    if minimize_supercells:\n        print(\n            f\"We have {len(self.sc_matrices)} q-points in IBZ necessitating \"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{np.sum(self.sc_sizes)}\"\n        )\n        self._pick_smallest_supercells()\n        print(\n            f\"After minimization, we only need\"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{np.sum(self.sc_sizes)}\"\n        )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.convert_to_fraction_array","title":"<code>convert_to_fraction_array(arr)</code>","text":"<p>Takes a numpy array of floats and converts them to fractions.</p> <p>The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def convert_to_fraction_array(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Takes a numpy array of floats and converts them to fractions.\n\n    The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.\n    \"\"\"\n    result = np.empty((arr.shape[0], 2, arr.shape[1]), dtype=int)\n\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            frac = Fraction(arr[i, j]).limit_denominator()\n            result[i, 0, j] = frac.numerator\n            result[i, 1, j] = frac.denominator\n\n    return result\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_integers","title":"<code>find_integers(nums, g23, g12, g31, g123)</code>","text":"<p>Compute integers for off-diagonal supercell matrix elements Called by find_nondiagonal()</p> <p>This function is copied from QEPlayground</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_integers(nums, g23, g12, g31, g123):\n    \"\"\"\n    Compute integers for off-diagonal supercell matrix elements\n    Called by find_nondiagonal()\n\n    This function is copied from QEPlayground\n    \"\"\"\n    # Compute p (it's a modulo equation)\n    if g23 == 1:\n        p = 0\n    else:\n        for i in range(1, g23):\n            if (nums[1] + i * nums[2]) % g23 == 0:\n                p = i\n                break\n        # Compute q\n    g12_r = int(g12 / g123)\n    g23_r = int(g23 / g123)\n    g31_r = int(g31 / g123)\n    if g12_r == 1:\n        q = 0\n    else:\n        for i in range(1, g12_r):\n            if (g23_r * nums[0] + i * g31_r * nums[1]) % g12_r == 0:\n                q = i\n                break\n    # Compute r\n    gg_r = int(g31 * g23 / g123)\n    z = g23 * nums[0] / g12 + g31 * q * nums[1] / g12\n    if gg_r == 1:\n        r = 0\n    else:\n        for i in range(1, gg_r):\n            if (z + i * nums[2]) % gg_r == 0:\n                r = i\n                break\n    return p, q, r\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_nondiagonal","title":"<code>find_nondiagonal(Q)</code>","text":"<p>Nondiagonal supercell, based on [Phys. Rev. B 92, 184301] This function is copied from QEPlayground</p> <p>Parameters:</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_nondiagonal(Q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Nondiagonal supercell, based on [Phys. Rev. B 92, 184301]\n    This function is copied from QEPlayground\n\n    Parameters:\n    \"\"\"\n    # Take care of components already at Gamma\n    Q[1, np.where(Q[0] == 0)] = 1\n    # Shift the q-point into the positive quadrant of the reciprocal unit cell\n    Q[0, np.where(Q[0] &lt; 0)] += Q[1, np.where(Q[0] &lt; 0)]\n    # GCDs of Q[1] (in the logical order of the derivation)\n    g23 = math.gcd(Q[1, 1], Q[1, 2])\n    g12 = math.gcd(Q[1, 0], Q[1, 1])\n    g31 = math.gcd(Q[1, 2], Q[1, 0])\n    g123 = math.gcd(Q[1, 0], math.gcd(Q[1, 1], Q[1, 2]))\n    # Integers needed to solve the supercell matrix equation\n    p, q, r = find_integers(Q[0], g23, g12, g31, g123)\n    # Matrix elements (in order of derivation) and supercell matrix\n    S_33 = Q[1, 2]\n    S_22 = Q[1, 1] / g23\n    S_23 = p * Q[1, 2] / g23\n    S_11 = g123 * Q[1, 0] / (g12 * g31)\n    S_12 = q * g123 * Q[1, 1] / (g12 * g23)\n    S_13 = r * g123 * Q[1, 2] / (g31 * g23)\n    return np.array([[S_11, S_12, S_13], [0, S_22, S_23], [0, 0, S_33]])\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.minkowski_reduce_sc","title":"<code>minkowski_reduce_sc(T, lattice)</code>","text":"<p>Reduce a supercell matrix using Minkowski reduction.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>ndarray</code> <p>Supercell matrix.</p> required <code>lattice</code> <code>ndarray</code> <p>Primitive lattice.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def minkowski_reduce_sc(T, lattice):\n    \"\"\"\n    Reduce a supercell matrix using Minkowski reduction.\n\n    Args:\n        T (numpy.ndarray): Supercell matrix.\n        lattice (numpy.ndarray): Primitive lattice.\n\n    Returns:\n        numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.\n    \"\"\"\n    ndsc_lattice = np.dot(T, lattice)\n    ndsc_lattice = mink_reduce(ndsc_lattice)\n    T = np.dot(\n        ndsc_lattice,\n        np.linalg.inv(lattice),\n    )\n    return make_positive_det(np.rint(T).astype(int))\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.make_positive_det","title":"<code>make_positive_det(matrix)</code>","text":"<p>If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Input square matrix.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Adjusted matrix.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def make_positive_det(matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.\n\n    Args:\n        matrix (numpy.ndarray): Input square matrix.\n\n    Returns:\n        numpy.ndarray: Adjusted matrix.\n    \"\"\"\n    if np.linalg.det(matrix) &lt; 0:\n        # Find the row index with the most negative entries\n        negative_sums = np.sum(np.minimum(matrix, 0), axis=1)\n        row_to_flip = np.argmin(negative_sums)\n        matrix[row_to_flip] *= -1\n\n    return matrix\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce","title":"<code>mink_reduce(vecs, tol=1e-07, max_iter=100)</code>","text":"<p>Perform Minkowski reduction on a set of 3 vectors in 3D space.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row represents a 3D vector. tol : float, optional     Tolerance for floating-point comparisons, default is 1e-7. max_iter : int, optional     Maximum number of iterations, default is 100.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--returns","title":"Returns","text":"<p>np.ndarray     Minkowski-reduced vectors.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def mink_reduce(vecs: np.ndarray, tol: float = 1e-7, max_iter: int = 100) -&gt; np.ndarray:\n    \"\"\"\n    Perform Minkowski reduction on a set of 3 vectors in 3D space.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row represents a 3D vector.\n    tol : float, optional\n        Tolerance for floating-point comparisons, default is 1e-7.\n    max_iter : int, optional\n        Maximum number of iterations, default is 100.\n\n    Returns\n    -------\n    np.ndarray\n        Minkowski-reduced vectors.\n    \"\"\"\n    if vecs.shape != (3, 3):\n        raise ValueError(\"Input must have shape (3, 3).\")\n\n    i = 0\n    while True:\n        # Keep track of whether any reduction occurred\n        changed = False\n\n        for i in range(3):\n            temp_vecs = vecs.copy()\n            temp_vecs[i] = 0.0  # Temporarily zero out the i-th vector\n            reduced_vecs = reduce_vectors(temp_vecs, tol)\n            reduced_vecs[i] = vecs[i]  # Restore the i-th vector\n\n            if not np.allclose(reduced_vecs, vecs):\n                vecs = reduced_vecs\n                changed = True\n                break\n\n        # Check combinations involving all three vectors\n        if not changed:\n            reduced_vecs = reduce_vectors(vecs, tol)\n            if not np.allclose(reduced_vecs, vecs, atol=tol, rtol=0):\n                vecs = reduced_vecs\n                continue\n\n        # Stop if no changes occurred in this iteration\n        if not changed:\n            break\n\n        i += 1\n        if i &gt; max_iter:\n            raise RuntimeError(\"Too many iterations in Minkowski reduction.\")\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors","title":"<code>reduce_vectors(vecs, tol)</code>","text":"<p>Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row is a 3D vector. tol : float     Tolerance for floating-point comparisons.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--returns","title":"Returns","text":"<p>np.ndarray     A new array with the reduced vectors if a reduction occurs, or the original array unchanged.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def reduce_vectors(vecs: np.ndarray, tol: float) -&gt; np.ndarray:\n    \"\"\"\n    Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row is a 3D vector.\n    tol : float\n        Tolerance for floating-point comparisons.\n\n    Returns\n    -------\n    np.ndarray\n        A new array with the reduced vectors if a reduction occurs, or the original array unchanged.\n    \"\"\"\n    lengths_sq = np.sum(vecs**2, axis=1)\n    longest_idx = np.argmax(lengths_sq)\n    max_len_sq = lengths_sq[longest_idx]\n\n    a, b, c = vecs\n    candidates = [\n        a + b - c,\n        a - b + c,\n        -a + b + c,\n        a + b + c,\n    ]\n\n    for candidate in candidates:\n        if np.dot(candidate, candidate) &lt; max_len_sq * (1 - tol):\n            new_vecs = vecs.copy()\n            new_vecs[longest_idx] = candidate\n            return new_vecs\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/symmetries/","title":"symmetries","text":""},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer","title":"<code>Symmetrizer(primitive, threshold=1e-05)</code>","text":"<p>The constructor takes the pymatgen Structure object and sets up attributes in a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.</p> <p>Parameters:</p> Name Type Description Default <code>primitive</code> <code>Primitive</code> <p>The primitive cell of the structure</p> required <code>Threshold</code> <p>Numerical threshold for symmetry detection, defaults to 1e-5.</p> required Source code in <code>quesadilla/symmetries.py</code> <pre><code>def __init__(\n    self,\n    primitive: Primitive,\n    threshold: float = 1e-5,\n):\n    \"\"\"Initialize a symmetry analysis object for a structure.\n\n    The constructor takes the pymatgen Structure object and sets up attributes in\n    a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO\n    symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.\n\n    Args:\n        primitive: The primitive cell of the structure\n        Threshold: Numerical threshold for symmetry detection, defaults to 1e-5.\n    \"\"\"\n\n    # Define QE Variables with fortran-ready data types\n    # NOTE: we use the same names as the QE Fortran routines\n    # self.nat = np.intc(len(structure))  # Number of atoms\n    self.nat = np.intc(len(primitive))  # Number of atoms\n    # assert self.nat == self.nat2, \"Number of atoms do not match\"\n    # s(:,:,i) is the i-th symmetry operation. Zeros for missing symmetries\n    self.s = np.zeros((3, 3, 48), dtype=np.intc, order=\"F\")\n    # irt(i,j) is the index of the atom you get from applying symmetry i to atom j\n    self.irt = np.zeros((48, self.nat), dtype=np.intc, order=\"F\")\n    # Array with index of inverse symmetry of each operation\n    self.invs = np.zeros((48), dtype=np.intc, order=\"F\")\n    # Array with S.r_a - r_a for each symm op and atom a\n    self.rtau = np.zeros((3, 48, self.nat), dtype=np.float64, order=\"F\")\n    # ft(:, j) is the fractional translation of symmetry j in FRAC coords\n    self.ft = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the crystal\n    self.nsym = np.intc(0)\n    # Number of symmetries in the Bravais lattice\n    self.nrot = np.intc(0)\n\n    # Whether there is a symm op S_{-} such that S_{-} . q = -q + G\n    self.minus_q = np.array([True], dtype=np.intc)\n    # s(:, :, irotmq) is the symmetry operation that maps q to -q + G\n    self.irotmq = np.intc(0)\n    # This is the G vector in S_{-} . q = -q + G\n    self.gimq = np.zeros((3), dtype=np.float64, order=\"F\")\n    # gi(:, i) is the G vector in S(:,:,i)@q = q + G\n    self.gi = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the star of a q-point\n    self.nsymq = np.intc(0)\n\n    # Assign unique number to each species\n    mapping = {element: i + 1 for i, element in enumerate(set(primitive.symbols))}\n    self.ityp = np.array(\n        [mapping[element] for element in primitive.symbols], dtype=np.intc\n    )\n    # Atoms' cartesian coordinates\n    self.tau = primitive.positions.T\n    # # Lattice vectors (QE routines expect columns as basis vectors)\n    self.at = np.array(primitive.cell.T, dtype=np.float64, order=\"F\")\n    # Reciprocal lattice vectors/(2pi) (QE routines expect columns as basis vectors)\n    recip_lattice = np.linalg.inv(primitive.cell).T * (2 * np.pi)\n    self.bg = np.array(recip_lattice.T / (2 * np.pi), dtype=np.float64, order=\"F\")\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_xq_from_aq","title":"<code>get_xq_from_aq(aq)</code>","text":"<p>Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>aq</code> <p>ndarray(3) The q-point in fractional coordinates.</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_xq_from_aq(self, aq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.\n\n    Parameters:\n        - aq : ndarray(3)\n            The q-point in fractional coordinates.\n\n    Returns:\n        ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n    \"\"\"\n    return np.dot(aq, self.bg.T)\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_aq_from_xq","title":"<code>get_aq_from_xq(xq)</code>","text":"<p>Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in fractional coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_aq_from_xq(self, xq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).\n\n    Parameters:\n        - xq : ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n\n    Returns:\n        ndarray(3)\n            The q-point in fractional coordinates.\n    \"\"\"\n    return np.dot(xq, np.linalg.inv(self.bg.T))\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_star_q","title":"<code>get_star_q(xq, verbose=False, debug=False)</code>","text":"<p>Get the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3), q point in CARTESIAN coordinates / (2 * pi)</p> required <code>-</code> <code>verbose</code> <p>bool Whether to print the number of q-points in the star and the list of q-points in the star.</p> required <code>-</code> <code>debug</code> <p>bool Whether to print debug information from Fortran routines.</p> required <p>Returns:</p> Type Description <p>ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_star_q(self, xq: ArrayLike, verbose: bool = False, debug: bool = False):\n    # sourcery skip: extract-method\n    \"\"\"\n    Get the star of a q-point.\n\n    Parameters:\n        - xq : ndarray(3), q point in CARTESIAN coordinates / (2 * pi)\n        - verbose : bool\n            Whether to print the number of q-points in the star and the list of q-points in the star.\n        - debug : bool\n            Whether to print debug information from Fortran routines.\n\n    Returns:\n        ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)\n    \"\"\"\n    # To get the star we need the symmetries of the WHOLE CRYSTAL\n    # So that's just the litle group of the Gamma point\n    self._setup_little_group(np.array([0, 0, 0]), verbose)\n    # Return values are:\n    # 1. number of q-points in the star\n    # 2. The vector that q is mapped to under each symmop\n    # 3. Index of q in sxq\n    # 4. Index of -q in sxq, 0 if not present\n    self.nqs, self.sxq, self.isq, self.imq = espresso_symm.star_q(\n        xq,  # q point in cartesian coordinates/2pi\n        self.at,  # lattice vectors (see __init__ for format)\n        self.bg,  # rec. lattice vectors (see __init__ for format)\n        self.nsym,  # Number of symmetries in the small group of q\n        self.s,  # Array of ALL symmetries of the crystal\n        self.invs,  # Index of inverse of s in self.s\n        False,  # Debug flag\n    )\n    star_xq = self.sxq[:, : self.nqs].T\n    if verbose:\n        q_star = np.array([self.get_aq_from_xq(xqs) for xqs in star_xq])\n        print(\"Number of q in the star:\", self.nqs)\n        print(\"List of q in the star:\")\n        for i, qq in enumerate(q_star):\n            print(f\"{i+1}    {np.round(qq, 8)}\")\n        if self.imq == 0:\n            print(\"In addition, there is the -q list, which is NOT in the star:\")\n            for i, qq in enumerate(q_star):\n                print(f\"{i+1+self.nqs}    {np.round(qq, 8)}\")\n        else:\n            mq = self.get_aq_from_xq(self.sxq[:, self.imq - 1])  # -q\n            gmq = self.get_aq_from_xq(self.gimq)  # G\n            q = self.get_aq_from_xq(xq)  # q\n            print(\"-q is also in the star: \", np.round(mq, 8))\n            print(\"With G = \", np.round(gmq, 8))\n            print(\"So that S_ @ q - (-q + G)\", np.round(mq + q - gmq, 5))\n\n    return star_xq\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.symmetrize_fcq","title":"<code>symmetrize_fcq(fcq, xq, verbose=False)</code>","text":"<p>Symmetrize the force constants at a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in CARTESIAN coordinates / (2 * pi)</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>(3 * nat, 3 * nat)</code> <p>The symmetrized force constants at q in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def symmetrize_fcq(self, fcq: ArrayLike, xq: ArrayLike, verbose: bool = False):\n    \"\"\"\n    Symmetrize the force constants at a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in CARTESIAN coordinates / (2 * pi)\n\n    Returns:\n        ndarray(3 * nat, 3* nat): The symmetrized force constants at q in FRACTIONAL coordinates.\n    \"\"\"\n    self._setup_little_group(xq, verbose)\n    return espresso_symm.symdynph_gq_new(\n        xq,\n        self.at,\n        self.bg,\n        fcq,\n        self.s,\n        self.invs,\n        self.rtau,\n        self.irt,\n        self.nsymq,\n        self.irotmq,\n        self.minus_q,\n    )\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_fcq_in_star","title":"<code>get_fcq_in_star(fcq, aq, verbose=True)</code>","text":"<p>Get the force constants in the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), Fourier-transformed force constants         in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in FRACTIONAL coordinates</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3nat x 3nat matrix in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_fcq_in_star(self, fcq, aq, verbose=True):\n    \"\"\"\n    Get the force constants in the star of a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), Fourier-transformed force constants\n                    in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in FRACTIONAL coordinates\n\n    Returns:\n        dict: The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3*nat x 3*nat matrix in FRACTIONAL coordinates.\n    \"\"\"\n\n    # Symmetrize the force constants at q\n    aq = np.array(aq, dtype=np.float64, order=\"F\")\n    xq = self.get_xq_from_aq(aq)\n    fcq = np.array(fcq, dtype=np.complex128, order=\"F\")\n    fcq_symm = self.symmetrize_fcq(fcq, xq, verbose)\n\n    # Get star of the q-point\n    star_xq = self.get_star_q(xq, verbose)\n    # In the special case that -q is NOT in the star,\n    # We compute the FCQ at -q anyway using TRS and include it\n    if self.imq == 0:\n        nq_tot = 2 * self.nqs\n        star_xq = np.concatenate((star_xq, -star_xq), axis=0)\n    else:\n        nq_tot = self.nqs\n\n    # Get the FC(q) in the star\n    fcq_star = espresso_symm.q2qstar_ph(\n        fcq_symm,\n        self.at,\n        self.bg,\n        self.nsym,\n        self.s,\n        self.invs,\n        self.irt,\n        self.rtau,\n        self.nqs,\n        self.sxq,\n        self.isq,\n        self.imq,\n        nq_tot,\n    )\n\n    # Turn into a dictionary\n    final_fcq = {}\n    for i, xqq in enumerate(star_xq):\n        qq = self.get_aq_from_xq(xqq)\n        final_fcq[tuple(qq)] = fcq_star[i, :, :]\n\n    return final_fcq\n</code></pre>"},{"location":"reference/quesadilla/utils/","title":"utils","text":""},{"location":"reference/quesadilla/utils/#quesadilla.utils.write_lwm","title":"<code>write_lwm(prim, grid, path)</code>","text":"<p>Writes the lattice matrix, irreducible q-points, and grid to files suitable for input to Lloyd-Williams and Monserrat's code.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <code>Structure</code> <p>The primitive structure.</p> required <code>grid</code> <code>list</code> <p>The grid of q-points.</p> required <code>path</code> <code>str</code> <p>The directory to write the files to.</p> required Source code in <code>quesadilla/utils.py</code> <pre><code>def write_lwm(prim, grid, path):\n    \"\"\"\n    Writes the lattice matrix, irreducible q-points, and grid to files\n    suitable for input to Lloyd-Williams and Monserrat's code.\n\n    Args:\n        prim (pymatgen.Structure): The primitive structure.\n        grid (list): The grid of q-points.\n        path (str): The directory to write the files to.\n    \"\"\"\n    sga = SpacegroupAnalyzer(prim)\n    q_irr = sga.get_ir_reciprocal_mesh(grid)\n    q_irr = np.array([q[0] for q in q_irr])\n    # Write lattice matrix to path/prim.dat\n    np.savetxt(f\"{path}/prim.dat\", prim.lattice.matrix, fmt=\"%.10f\")\n    # Write irreducible q-points to path/ibz.dat\n    np.savetxt(f\"{path}/ibz.dat\", q_irr, fmt=\"%.10f\")\n    # Write grid to path/grid.dat\n    np.savetxt(f\"{path}/grid.dat\", np.array(grid), fmt=\"%d\", newline=\" \")\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.read_lwm","title":"<code>read_lwm(path)</code>","text":"<p>Reads kpoint_to_supercell.dat and associated supercell files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the directory containing kpoint_to_supercell.dat and supercell..dat files. required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def read_lwm(path):\n    \"\"\"\n    Reads kpoint_to_supercell.dat and associated supercell files.\n\n    Args:\n        path (str): Path to the directory containing kpoint_to_supercell.dat and supercell.&lt;i&gt;.dat files.\n\n    Returns:\n        tuple: A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).\n    \"\"\"\n    # File paths\n    kpoint_file = os.path.join(path, \"kpoint_to_supercell.dat\")\n\n    # Read kpoint_to_supercell.dat using NumPy\n    kpoint_data = np.loadtxt(kpoint_file)\n\n    # Extract vectors (first 3 columns) and indices (last column)\n    q = kpoint_data[:, :3]\n    indices = kpoint_data[:, 3].astype(int)\n\n    # Read the associated supercell matrices\n    matrices = []\n    for i in indices:\n        supercell_file = os.path.join(path, f\"supercell.{i}.dat\")\n        T = np.loadtxt(supercell_file, dtype=int)  # Read the 3x3 matrix\n        matrices.append(make_positive_det(T))\n        # for qq in q:\n        qq = q[i - 1]\n        assert np.allclose(\n            T @ qq, np.round(T @ qq)\n        ), \"Supercell {i} is not commensurate with q = {qq}\"\n\n    return np.array(matrices), np.array(q)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.get_KPOINTS","title":"<code>get_KPOINTS(struct, kspace)</code>","text":"<p>TODO: switch to autoGR Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5. Parameters:</p> <p>struct : pymatgen.Structure     The structure object. kspace : float     The spacing of the k-point mesh in 1/\u00c5. Returns:</p> <p>kpoints : pymatgen.io.vasp.inputs.Kpoints     The KPOINTS object.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def get_KPOINTS(struct, kspace):\n    \"\"\"\n    TODO: switch to autoGR\n    Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5.\n    Parameters:\n    -----------\n    struct : pymatgen.Structure\n        The structure object.\n    kspace : float\n        The spacing of the k-point mesh in 1/\u00c5.\n    Returns:\n    --------\n    kpoints : pymatgen.io.vasp.inputs.Kpoints\n        The KPOINTS object.\n    \"\"\"\n    assert kspace &gt; 0, \"argument kspace must not be negative\"\n    b = np.array(struct.lattice.reciprocal_lattice.matrix)\n    N = np.maximum(\n        np.array([1, 1, 1]), np.round(np.sqrt(np.sum(b**2, axis=1)) / kspace)\n    ).astype(np.int64)\n    k_dict = {\n        \"nkpoints\": 0,\n        \"generation_style\": \"Gamma\",\n        \"kpoints\": [[N[0], N[1], N[2]]],\n        \"usershift\": [0, 0, 0],\n        \"comment\": f\"Mesh with spacing {kspace} 1/\u00c5\",\n    }\n    return Kpoints.from_dict(k_dict)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.generate_files","title":"<code>generate_files(primitive_filename, grid, k_spacing=0.15, verbose=False)</code>","text":"<p>Generates the files for an NDSC phonon calculation.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def generate_files(\n    primitive_filename: str, grid: list, k_spacing: float = 0.15, verbose: bool = False\n):\n    \"\"\"\n    Generates the files for an NDSC phonon calculation.\n    \"\"\"\n\n    root = os.path.dirname(primitive_filename)\n    primitive = get_phonopy_prim(primitive_filename)\n    sc_gen = SupercellGenerator(primitive, grid)\n    sc_gen.generate_supercells()\n\n    # pymatgen structure object\n    new_prim_filename = os.path.join(root, \"POSCAR_standard_primitive\")\n    prim = Structure.from_file(new_prim_filename)\n\n    T_matrices, sc_size, comm_q = sc_gen.sc_matrices, sc_gen.sc_sizes, sc_gen.q_comm\n    for i, (T, sz, q) in enumerate(zip(T_matrices, sc_size, comm_q)):\n        # Print the supercell information\n        if verbose:\n            print(\n                (\n                    f\"Supercell {i+1} with size {sz} is commensurate with q = \"\n                    f\"{np.round(q, 3)}\"\n                )\n            )\n            print(\"Supercell matrix:\")\n            print(T)\n        # Generate the supercell\n        sc_path = os.path.join(root, f\"sc-{i+1}\")\n        os.makedirs(sc_path, exist_ok=True)\n        sc = prim.copy()\n        sc.make_supercell(T)\n        prim.to(filename=os.path.join(sc_path, \"POSCAR\"), fmt=\"poscar\")\n        sc.to(filename=os.path.join(sc_path, \"quesadilla_ndsc.vasp\"), fmt=\"poscar\")\n        get_KPOINTS(sc, k_spacing).write_file(os.path.join(sc_path, \"KPOINTS\"))\n\n        # DIM string uses supercell matrix, flattened. Phonopy uses transpose\n        T_str = \" \".join([f\"{int(x):d}\" for x in T.T.flatten()])\n        with open(os.path.join(sc_path, \"make_disp.conf\"), \"w\") as f:\n            f.write(MAKE_DISP.format(T_str))\n        with open(os.path.join(sc_path, \"get_yaml.conf\"), \"w\") as f:\n            f.write(GET_YAML.format(T_str))\n    sc_gen.to_toml(os.path.join(root, \"quesadilla.toml\"))\n</code></pre>"},{"location":"reference/tools/run_f2py/","title":"run_f2py","text":""}]}