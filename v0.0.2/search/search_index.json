{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quesadilla","text":"<p>Quesadilla (Queue-saving nondiagonal superlattices) is a python package for nondiagonal supercell phonon calculations, using the approach of Lloyd-Williams and Monserrat</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>The quesadilla command line interface is very similar to phonopy's. Regardless of what DFT code you're using, the steps are more or less the same.</p>"},{"location":"tutorial/#step-1-generate-supercells-with-displacements","title":"Step 1: Generate supercells with displacements","text":"<p>With phonopy, you would run something like <code>phonopy -d --dim 4 4 4</code>, perhaps with extra arguments if you don't use VASP (e.g., <code>phonopy --qe -d --dim 4 4 4 -c pw.in</code>). The first step with quesadilla is to use the exact same command, but with <code>phonopy</code> replaced with <code>quesadilla</code>:</p> <pre><code># Assumes you use VASP and POSCAR is in current directory\nquesadilla -d --dim 4 4 4\n</code></pre> <p>or </p> <pre><code># Quantum espresso example\nquesadilla --qe -d --dim 4 4 4 -c pw.in\n</code></pre> <p>quesadilla also supports all the other <code>phonopy</code> arguments you may want to use when generating the displacements, such as <code>--pm</code>, <code>--trigonal</code>, etc.</p> <p>In a conventional <code>phonopy</code> calculation, this would have produced a pristine 4x4x4 supercell file (e.g., <code>SPOSCAR</code>) as well as some supercells with displacements (e.g., <code>POSCAR-00{1,2,3...}</code>) and a <code>phonopy_disp.yaml</code>. With quesadilla, the situation is quite similar but with some extra steps:</p> <ol> <li>First, quesadilla will find a standard primitive cell. This is similar to running <code>phonopy --symmetry</code>. This standard primitive cell is what will be used to build the nondiagonal supercell, and will be saved in a file <code>PPOSCAR</code>.</li> <li>Next, quesadilla will figure out the minimum number of nondiagonal supercells necessary to span the 4x4x4 q-grid, build them, and then Minkowski reduce them. These files will be placed in the directories <code>sc-{001,002,...}</code>, each corresponding to a nondiagonal supercell. Each NDSC will be in, e.g., the <code>sc-*/SPOSCAR</code> file for VASP. The standard primitive <code>POSCAR</code> file will also be placed in these directories.</li> <li>Finally, quesadilla will generate the displacemnts in each of these supercells, producing the files <code>sc-*/POSCAR-*</code>. This is similar to running <code>phonopy -d --dim &lt;ndsc matrix&gt;</code> on every single supercell. </li> </ol> <p>Each <code>sc-*</code> folder will also have a <code>phonopy_disp.yaml</code> file, which can be used for debugging if necessary, and will be read later when creating the force sets. In the root directory where the primitive cell is located, quesadilla will also write a file <code>quesadilla.toml</code> with a log of the number of supercells, their sizes, the q-points they are commensurate with, etc.</p>"},{"location":"tutorial/#step-2-run-the-dft-calculations","title":"Step 2: run the DFT calculations","text":"<p>As usual with <code>phonopy</code>, we now have to run the DFT calculations on the supercells with the displacements. We will place each <code>POSCAR-x</code> in a directory <code>disp-x</code> and run the calculation there (e.g., <code>POSCAR-002</code> should go in a directory <code>disp-002</code>). While this directory structure is optional for phonopy, it is mandatory for quesadilla. This needs to be repeated for every single supercell (i.e., for each <code>sc-{i}</code> directory). Optionally, the forces in the pristine supercell can also be calculated so they can be subtracted from the force sets in the next step. If this is desired, the pristine supercell calculation (e.g., the <code>SPOSCAR</code> file) should be run in the <code>disp-000</code> folder.</p> <p>Note that, since nondiagonal supercells have lower symmetry, you may require more displacements than you would for a diagonal cell. For example, a 4x4x4 diagonal supercell of Si will only require the calculation of one supercell with displacements, whereas with nondiagonal supercells we will need 4 supercells with 2 displacements each and 1 supercell with 4 displacements.</p>"},{"location":"tutorial/#step-3-generate-the-force-sets-force_sets","title":"Step 3: generate the force sets (<code>FORCE_SETS</code>)","text":"<p>The next step is to generate the <code>FORCE_SETS</code> file. In phonopy, we would use something like <code>phonopy disp-00{1..4}/vasprun.xml</code> to read the forces from the <code>vasprun.xml</code> for the four supercells with displacements. Here, we have five nondiagonal supercells with varying numbers of displacements each. As mentioned earlier, your calculations should always be structured so that <code>POSCAR-001</code> (and the resultant <code>vasprun.xml</code> or similar output file) go into the folder <code>disp-001</code>, etc. To generate the <code>FORCE_SETS</code> for all supercells with <code>quesadilla</code>, we can run from the root directory</p> <pre><code>quesadilla -f vasprun.xml\n</code></pre> <p>which is similar to running <code>phonopy -f disp-*/vasprun.xml</code> in every <code>sc-*</code> directory, generating one <code>FORCE_SETS</code> file per supercell. If you want to use the <code>--force-sets-zero</code> option, subtracting the residual forces from the pristine supercell, then with quesadilla we'll run</p> <pre><code>quesadilla --force-sets-zero vasprun.xml\n</code></pre> <p>assuming the pristine supercell calculation was done in the <code>sc-*/disp-000</code> directories as explained in the previous section.</p>"},{"location":"tutorial/#step-4-generate-the-force-constants","title":"Step 4: generate the force constants","text":"<p>Finally, we need to generate the force constants. This is a little bit different from <code>phonopy</code> where often you won't generate them explicitly. The command is (from the root directory)</p> <pre><code>quesadilla --fc\n</code></pre> <p>which will do the following: 1. From the force sets (<code>FORCE_SETS</code>) file in each <code>sc-*</code> directory, it will compute the real-space force constants for this specific NDSC. 2. Next, for each NDSC, it will compute the dynamical matrix at every q-point that supercell it is commensurate with. 3. If a q-point is commensurate with multiple cells (such as the \\(\\Gamma\\) point, commensurate with all of them), the dynamical matrix is averaged. We now have the dynamical matrix at every \\(q\\) point in the iredducible Brillouin zone. 4. Next, quesadilla will symmetrize the reciprocal-space dynamical matrix using the symmetries of the little group of each q-point. This can get rid of small symmetry breaking problems that can happen in non-diagonal supercells. 5. Using the symmetrized dynamical matrices, quesadilla will calculate the star of each q-point in the iredducible brillouin zone, then use space group symmetries, and time reversal symmetry if applicable, to compute the dynamical matrix at every point in the star of q. 6. Once this is done, we now have the dynamical matrix in the full Brillouin zone. We can now Fourier transform it to real space to obtain the force constant matrix of a diagonal 4x4x4 supercell. 7. Finally, quesadilla will apply the acoustic sum rules (ASR) to enforce translational symmetry.</p> <p>As a result of this command, a <code>phonopy.yaml</code> file containing all the calculation information and the force constants will be produced in the root directory. This file can now be used with <code>phonopy</code>. <code>phono3py</code>, DarkMAGIC, or any other code that reads <code>phonopy.yaml</code> files. Since it contains the full force constants, we don't need a <code>FORCE_CONSTANTS</code> or <code>force_constants.hdf5</code> file, but they can be dumped explicitly from this <code>phonopy.yaml</code> by using <code>phonopy</code> itself.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>quesadilla<ul> <li>cli</li> <li>dynmat</li> <li>supercells</li> <li>symmetries</li> <li>utils</li> </ul> </li> <li>tools<ul> <li>run_f2py</li> </ul> </li> </ul>"},{"location":"reference/quesadilla/","title":"quesadilla","text":""},{"location":"reference/quesadilla/cli/","title":"cli","text":"<p>Quesadilla command line interface</p>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.get_parser","title":"<code>get_parser()</code>","text":"<p>Return ArgumentParser instance.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def get_parser():\n    \"\"\"Return ArgumentParser instance.\"\"\"\n\n    parser = argparse.ArgumentParser(\n        description=\"Phonopy command-line-tool\", allow_abbrev=False\n    )\n\n    add_arguments_of_calculators(parser, calculator_info)\n\n    # GENERAL\n    parser.add_argument(\n        \"--config\",\n        dest=\"conf_filename\",\n        metavar=\"FILE\",\n        default=None,\n        help=\"Phonopy configuration file\",\n    )\n    parser.add_argument(\n        \"--loglevel\", dest=\"loglevel\", type=int, default=None, help=\"Log level\"\n    )\n    # TODO: implement magnetism\n    parser.add_argument(\n        \"--magmom\", nargs=\"+\", dest=\"magmoms\", default=None, help=\"Same as MAGMOM tag\"\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"store_true\",\n        default=None,\n        help=\"Print out smallest information\",\n    )\n    parser.add_argument(\n        \"--random-seed\",\n        dest=\"random_seed\",\n        type=int,\n        default=None,\n        help=\"Random seed by a 32 bit unsigned integer\",\n    )\n    parser.add_argument(\n        \"--tolerance\",\n        dest=\"symmetry_tolerance\",\n        type=float,\n        default=None,\n        help=\"Symmetry tolerance to search\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        dest=\"verbose\",\n        action=\"store_true\",\n        default=None,\n        help=\"Detailed information is shown.\",\n    )\n    parser.add_argument(\n        \"filename\",\n        nargs=\"*\",\n        help=(\n            \"Phonopy configure file. However if the file is recognized as \"\n            \"phonopy.yaml like file, this file is read as phonopy.yaml like file.\"\n        ),\n    )\n    ###################################\n    # MODE 1 : pre-process\n    ###################################\n    # -----------------------------\n    # Required in this mode\n    parser.add_argument(\n        \"-d\",\n        \"--displacement\",\n        dest=\"is_displacement\",\n        action=\"store_true\",\n        default=None,\n        help=\"Create supercells with displacements\",\n    )\n    parser.add_argument(\n        \"--dim\",\n        nargs=\"+\",\n        dest=\"supercell_dimension\",\n        default=None,\n        help=\"Same behavior as DIM tag\",\n    )\n    # ----------------------\n    # Good default is guessed depending on the calculator\n    parser.add_argument(\n        \"-c\",\n        \"--cell\",\n        dest=\"cell_filename\",\n        metavar=\"FILE\",\n        default=None,\n        help=\"Read unit cell\",\n    )\n    # Control of displacement pattern\n    parser.add_argument(\n        \"--amplitude\",\n        \"--amin\",\n        dest=\"displacement_distance\",\n        type=float,\n        default=None,\n        help=(\n            \"Distance of displacements and also minimum distance of displacements \"\n            \"in random displacements\"\n        ),\n    )\n    parser.add_argument(\n        \"--amax\",\n        dest=\"displacement_distance_max\",\n        type=float,\n        default=None,\n        help=\"Minimum distance of displacements in random displacements\",\n    )\n    parser.add_argument(\n        \"--nodiag\",\n        dest=\"is_nodiag\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set displacements parallel to axes\",\n    )\n    parser.add_argument(\n        \"--nosym\",\n        dest=\"is_nosym\",\n        action=\"store_true\",\n        default=None,\n        help=\"Symmetry is not imposed.\",\n    )\n    parser.add_argument(\n        \"--trigonal\",\n        dest=\"is_trigonal_displacements\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set displacements of all trigonal axes \",\n    )\n    parser.add_argument(\n        \"--pm\",\n        dest=\"is_plusminus_displacements\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set plus minus displacements\",\n    )\n    # TODO: not sure how to deal with this one?\n    parser.add_argument(\n        \"--wien2k-p1\",\n        dest=\"is_wien2k_p1\",\n        action=\"store_true\",\n        default=None,\n        help=\"Assume Wien2k structs with displacements are P1\",\n    )\n\n    # MODE 2: post-process\n    # -----------------------------\n    # MODE 2.1: generate force sets\n    # -----------------------------\n    parser.add_argument(\n        \"-f\",\n        \"--force-sets\",\n        nargs=\"+\",\n        dest=\"create_force_sets\",\n        default=None,\n        help=\"Create FORCE_SETS\",\n    )\n    parser.add_argument(\n        \"--fz\",\n        \"--force-sets-zero\",\n        nargs=\"+\",\n        dest=\"create_force_sets_zero\",\n        default=None,\n        help=(\n            \"Create FORCE_SETS. disp.yaml in the current directory and \"\n            \"vapsrun.xml's for VASP or case.scf(m) for Wien2k as arguments \"\n            \"are required. The first argument is that of the perfect \"\n            \"supercell to subtract residual forces\"\n        ),\n    )\n    # -----------------------------\n    # MODE 2.2: generate force constants\n    # -----------------------------\n    # NOTE: this tag works differently from phonopy\n    parser.add_argument(\n        \"--fc\",\n        \"--force-constants\",\n        dest=\"create_force_constants\",\n        action=\"store_true\",\n        default=None,\n        help=(\n            \"Create FORCE_CONSTANTS from vaspurn.xml. \"\n            \"vasprun.xml has to be passed as argument.\"\n        ),\n    )\n    # Force constant symmetry\n    # Should be hijaked and applied only to last step (ND D(q) -&gt; DSC D(q))\n    # Individual steps should not use symmetry\n    parser.add_argument(\n        \"--no-fc-symmetry\",\n        \"--no-sym-fc\",\n        dest=\"fc_symmetry\",\n        action=\"store_false\",\n        default=None,\n        help=\"Do not symmetrize force constants\",\n    )\n    parser.add_argument(\n        \"--fc-spg-symmetry\",\n        dest=\"fc_spg_symmetry\",\n        action=\"store_true\",\n        default=None,\n        help=\"Enforce space group symmetry to force constants\",\n    )\n    parser.add_argument(\n        \"--fc-symmetry\",\n        \"--sym-fc\",\n        dest=\"fc_symmetry\",\n        action=\"store_true\",\n        default=None,\n        help=\"Symmetrize force constants\",\n    )\n\n    return parser\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_displacements","title":"<code>create_displacements(sc_gen, settings, cell_info, log_level)</code>","text":"<p>Create displacements.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def create_displacements(\n    sc_gen: SupercellGenerator,\n    settings: PhonopySettings,\n    cell_info: dict,\n    log_level: int,\n):\n    \"\"\"\n    Create displacements.\n    \"\"\"\n    if settings.displacement_distance is None:\n        displacement_distance = get_default_displacement_distance(settings.calculator)\n    else:\n        displacement_distance = settings.displacement_distance\n\n    nd_phonons = []\n    cell_info_ndsc = cell_info.copy()\n    for i, sc_matrix in enumerate(sc_gen.sc_matrices):\n        # NOTE: phonopy convention is transposed compared to PRB 92, 184301 (2015)\n        cell_info_ndsc[\"supercell_matrix\"] = sc_matrix.T\n        phonon = _init_phonopy(\n            settings, cell_info_ndsc, settings.symmetry_tolerance, log_level\n        )\n        phonon.generate_displacements(\n            distance=displacement_distance,\n            is_plusminus=settings.is_plusminus_displacement,\n            is_diagonal=settings.is_diagonal_displacement,\n            is_trigonal=settings.is_trigonal_displacement,\n            number_of_snapshots=settings.random_displacements,\n            random_seed=settings.random_seed,\n            max_distance=settings.displacement_distance_max,\n        )\n        if log_level:\n            print(\n                f\"Nondiagonal supercell {i+1} needs {len(phonon.supercells_with_displacements)} displacements.\"\n            )\n        nd_phonons.append(phonon)\n\n    return nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.write_ndsc_with_displacement","title":"<code>write_ndsc_with_displacement(nd_phonons, calculator, confs, optional_structure_info)</code>","text":"<p>Write supercells with displacements as structure files</p> <p>Parameters:</p> Name Type Description Default <code>nd_phonons</code> <code>list[Phonopy]</code> <p>list of Phonopy objects for each NDSC</p> required <code>calculator</code> <code>str</code> <p>force calculator (e.g., \"vasp\")</p> required <code>confs</code> <code>dict</code> <p>dictionary of configuration as strings</p> required <code>optional_structure_info</code> <code>tuple</code> <p>output of read_cell_info</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def write_ndsc_with_displacement(\n    nd_phonons: list[Phonopy],\n    calculator: str,\n    confs: dict,\n    optional_structure_info: tuple,\n):\n    \"\"\"\n    Write supercells with displacements as structure files\n\n    Args:\n        nd_phonons: list of Phonopy objects for each NDSC\n        calculator: force calculator (e.g., \"vasp\")\n        confs: dictionary of configuration as strings\n        optional_structure_info: output of read_cell_info\n    \"\"\"\n    units = get_default_physical_units(calculator)\n    for i, phonon in enumerate(nd_phonons):\n        os.makedirs(f\"sc-{i+1:03d}\", exist_ok=True)\n        os.chdir(f\"sc-{i+1:03d}\")\n        write_crystal_structure(\n            get_default_cell_filename(calculator),\n            phonon.primitive,\n            interface_mode=calculator,\n            optional_structure_info=optional_structure_info,\n        )\n        # Write supercells with displacements as structure files\n        write_supercells_with_displacements(\n            phonon.calculator,\n            phonon.supercell,\n            phonon.supercells_with_displacements,\n            optional_structure_info=optional_structure_info,\n            additional_info={\"supercell_matrix\": phonon.supercell_matrix},\n        )\n        # Write phonopy_disp.yaml\n        _write_phonopy_disp_yaml(phonon, confs, units)\n        os.chdir(\"..\")\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.initialize_quesadilla","title":"<code>initialize_quesadilla()</code>","text":"<p>Initialize Quesadilla command line interface.</p> <p>Returns:</p> Name Type Description <code>PhonopySettings</code> <p>Phonopy settings</p> <code>dict</code> <p>Configuration settings</p> <code>str</code> <p>Cell filename</p> <code>int</code> <p>Log level</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def initialize_quesadilla():\n    \"\"\"\n    Initialize Quesadilla command line interface.\n\n    Returns:\n        PhonopySettings: Phonopy settings\n        dict: Configuration settings\n        str: Cell filename\n        int: Log level\n    \"\"\"\n    parser = get_parser()\n    args = parser.parse_args()\n    # Set log level\n    log_level = 1\n    if args.verbose:\n        log_level = 2\n    if args.quiet:\n        log_level = 0\n    if args.loglevel is not None:\n        log_level = args.loglevel\n\n    argparse_control = {\n        \"fc_symmetry\": False,\n        \"is_nac\": False,\n        \"load_phonopy_yaml\": False,\n    }\n    settings, confs, cell_filename = _read_phonopy_settings(\n        args, argparse_control, log_level\n    )\n\n    # These defaults are set internally inside multiple routines\n    # But I want to have them here from the get-go\n    if settings.calculator is None:\n        settings.calculator = \"vasp\"\n    if cell_filename is None:\n        cell_filename = get_default_cell_filename(settings.calculator)\n    if settings.symmetry_tolerance is None:\n        settings.symmetry_tolerance = 1e-5\n\n    # Ensure settings are correct\n    if settings.create_displacements or settings.random_displacements:\n        if settings.supercell_matrix is None:\n            raise ValueError(\"Supercell matrix is required for displacements\")\n        if not np.all(\n            np.diag(np.diag(settings.supercell_matrix)) == settings.supercell_matrix\n        ):\n            raise ValueError(\n                \"Supercell matrix (--dim or DIM) must be diagonal.\"\n                \"This is the size of your q-grid.\"\n            )\n\n    return settings, confs, cell_filename, log_level\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_force_sets","title":"<code>create_force_sets(settings, log_level, forces_filename)</code>","text":"<p>Create force sets from the displacements for each nondiagonal supercell.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>PhonopySettings</code> <p>Phonopy settings</p> required <code>log_level</code> <code>int</code> <p>Log level</p> required <code>forces_filename</code> <code>str</code> <p>The name of the file to read the forces from. This is the single argument of --force-sets or --force-sets-zero. Then for each supercell in the directory sc-i, the files to read forces from are disp-i/forces_filename.</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def create_force_sets(\n    settings: PhonopySettings,\n    log_level: int,\n    forces_filename: str,\n):\n    \"\"\"\n    Create force sets from the displacements for each nondiagonal supercell.\n\n    Args:\n        settings (PhonopySettings): Phonopy settings\n        log_level (int): Log level\n        forces_filename (str): The name of the file to read the forces from. This is the single argument of --force-sets or --force-sets-zero. Then for each supercell in the directory sc-i, the files to read forces from are disp-i/forces_filename.\n    \"\"\"\n    sc_gen = SupercellGenerator.from_toml(\"quesadilla.toml\")\n    for i in range(len(sc_gen.sc_matrices)):\n        os.chdir(f\"sc-{i+1:03d}\")\n        if log_level &gt; 0:\n            print(f\"Working on supercell {i+1} in directory sc-{i+1:03d}\")\n        _set_filenames_for_forcesets(settings, log_level, forces_filename)\n        _create_FORCE_SETS_from_settings(\n            settings,\n            \"phonopy_disp.yaml\",\n            settings.symmetry_tolerance,\n            log_level,\n        )\n        if log_level &gt; 0:\n            print(\"------------------------------------\")\n        os.chdir(\"..\")\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.get_sc_gen","title":"<code>get_sc_gen(settings, cell_filename)</code>","text":"<p>Prepares a supercell generate object from the settings and cell filename.</p> <p>This function dumps a standard primitive cell from the cell file and proceeds to create a SupercellGenerator object from it, and generate the supercells necessary to span the q-grid.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def get_sc_gen(settings, cell_filename):\n    \"\"\"\n    Prepares a supercell generate object from the settings and cell filename.\n\n    This function dumps a standard primitive cell from the cell file and\n    proceeds to create a SupercellGenerator object from it, and generate the supercells\n    necessary to span the q-grid.\n    \"\"\"\n    primitive, cell_info = get_phonopy_prim(\n        cell_filename, calculator=settings.calculator\n    )\n    grid = np.diag(settings.supercell_matrix)\n    sc_gen = SupercellGenerator(primitive, grid)\n    # TODO: add arguments for minkowski and minimize\n    sc_gen.generate_supercells(minimize_supercells=True)\n    sc_gen.to_toml(\"quesadilla.toml\")\n    return cell_info, sc_gen\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_force_constants","title":"<code>create_force_constants(settings, confs, log_level)</code>","text":"<p>Create force constants from the force sets for each nondiagonal supercell.</p> <p>Reads the quesadilla.toml file to setup the SupercellGenerator, reads the force sets from each of the sc-i directories for each NDSC and computes the force constants for each NDSC, then uses a NondiagonalPhononCalculator to compute the final force constants for the full diagonal supercell.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>PhonopySettings</code> <p>Phonopy settings</p> required <code>log_level</code> <code>int</code> <p>Log level</p> required <code>confs</code> <code>dict</code> <p>Configuration settings</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def create_force_constants(settings: Phonopy, confs: dict, log_level: int):\n    \"\"\"\n    Create force constants from the force sets for each nondiagonal supercell.\n\n    Reads the quesadilla.toml file to setup the SupercellGenerator,\n    reads the force sets from each of the sc-i directories for each NDSC and\n    computes the force constants for each NDSC, then uses a NondiagonalPhononCalculator\n    to compute the final force constants for the full diagonal supercell.\n\n    Args:\n        settings (PhonopySettings): Phonopy settings\n        log_level (int): Log level\n        confs (dict): Configuration settings\n    \"\"\"\n    sc_gen = SupercellGenerator.from_toml(\"quesadilla.toml\")\n    nd_phonons = _get_nd_phonons(sc_gen, settings, log_level)\n    ndsc_calc = NondiagonalPhononCalculator(sc_gen, nd_phonons)\n    ndsc_calc.run()\n    units = get_default_physical_units(settings.calculator)\n    _write_final_phonopy_yaml(ndsc_calc.phonons, confs, units)\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.main","title":"<code>main()</code>","text":"<p>Main function of Quesadilla command line interface.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def main():\n    \"\"\"Main function of Quesadilla command line interface.\"\"\"\n    settings, confs, cell_filename, log_level = initialize_quesadilla()\n\n    if settings.create_displacements or settings.random_displacements:\n        cell_info, sc_gen = get_sc_gen(settings, cell_filename)\n        nd_phonons = create_displacements(sc_gen, settings, cell_info, log_level)\n        write_ndsc_with_displacement(\n            nd_phonons, settings.calculator, confs, cell_info[\"optional_structure_info\"]\n        )\n        sys.exit(0)\n\n    if settings.create_force_sets or settings.create_force_sets_zero:\n        forces_filename = (\n            settings.create_force_sets[0]\n            if settings.create_force_sets\n            else settings.create_force_sets_zero[0]\n        )\n        create_force_sets(settings, log_level, forces_filename)\n        sys.exit(0)\n\n    if settings.create_force_constants:\n        create_force_constants(settings, confs, log_level)\n        sys.exit(0)\n</code></pre>"},{"location":"reference/quesadilla/dynmat/","title":"dynmat","text":""},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator","title":"<code>NondiagonalPhononCalculator(sc_gen, nd_phonons)</code>","text":"Source code in <code>quesadilla/dynmat.py</code> <pre><code>def __init__(self, sc_gen: SupercellGenerator, nd_phonons: list[Phonopy]):\n    self.sc_gen = sc_gen\n    self.nd_phonons = nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator.from_toml","title":"<code>from_toml(toml_file)</code>  <code>classmethod</code>","text":"<p>Create a NondiagonalPhononCalculator object from a toml file.</p> <p>Generally the toml file is called quesadilla.toml and will be in the same directory as the sc-i directories, each of which should contain a phonopy.yaml file THAT MUST INCLUDE THE FORCE CONSTANTS computed from this supercell.</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>Path</code> <p>Path to the toml file</p> required <p>Returns:</p> Type Description <p>A NondiagonalPhononCalculator object</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>@classmethod\ndef from_toml(cls, toml_file: Path):\n    \"\"\"\n    Create a NondiagonalPhononCalculator object from a toml file.\n\n    Generally the toml file is called quesadilla.toml and will be\n    in the same directory as the sc-i directories, each of which\n    should contain a phonopy.yaml file THAT MUST INCLUDE THE\n    FORCE CONSTANTS computed from this supercell.\n\n    Args:\n        toml_file: Path to the toml file\n\n    Returns:\n        A NondiagonalPhononCalculator object\n    \"\"\"\n    # TODO: move to CLI (maybe?)\n    sc_gen = SupercellGenerator.from_toml(toml_file)\n    root = os.path.dirname(toml_file)\n    nd_phonons = cls._parse_ndsc_phonons(root, sc_gen)\n\n    return cls(sc_gen, nd_phonons)\n</code></pre>"},{"location":"reference/quesadilla/supercells/","title":"supercells","text":""},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator","title":"<code>SupercellGenerator(atoms, grid, q_ibz=None, sc_matrices=None, sc_sizes=None, q_comm=None)</code>","text":"Source code in <code>quesadilla/supercells.py</code> <pre><code>def __init__(\n    self,\n    atoms: PhonopyAtoms,\n    grid: ArrayLike,\n    q_ibz: np.ndarray = None,\n    sc_matrices: np.ndarray = None,\n    sc_sizes: np.ndarray = None,\n    q_comm: list = None,\n):\n    # Setup primitive structure and supercell\n    grid = np.array(grid)\n    self.supercell = Supercell(atoms, np.diag(grid))\n    self.primitive = Primitive(self.supercell, np.diag(1 / grid))\n    # Setup BZ data\n    self.grid = grid\n    if q_ibz is None:\n        self.q_ibz = self.get_ibz()\n    else:\n        q_ibz = np.array(q_ibz)\n        q_ibz = q_ibz[np.lexsort(q_ibz.T)]\n        try:\n            assert np.allclose(q_ibz, self.get_ibz())\n        except AssertionError as e:\n            raise ValueError(\n                \"IBZ q-points passed do not match what we expect from the \"\n                \"structure's symmetry.\"\n            ) from e\n\n    # Setup supercell data\n    self.sc_matrices = np.array(sc_matrices) if sc_matrices is not None else None\n    self.sc_sizes = np.array(sc_sizes) if sc_sizes is not None else None\n    self.q_comm = q_comm\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.get_ibz","title":"<code>get_ibz()</code>","text":"<p>Gets the q points in a structures IBZ. The output is sorted for consistency.</p> <ul> <li>primitive: phonopy.structure.cells.Primitive     The input structure (primitive cell, assumed to be standardized).</li> <li>grid: array-like     The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).</li> </ul> <ul> <li>qpoints: numpy.ndarray     The q points in the IBZ (fractional coordinates, sorted).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def get_ibz(\n    self,\n) -&gt; np.ndarray:\n    \"\"\"\n    Gets the q points in a structures IBZ. The output is sorted for consistency.\n\n    Parameters:\n    - primitive: phonopy.structure.cells.Primitive\n        The input structure (primitive cell, assumed to be standardized).\n    - grid: array-like\n        The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).\n\n    Returns:\n    - qpoints: numpy.ndarray\n        The q points in the IBZ (fractional coordinates, sorted).\n    \"\"\"\n    grid = np.array(self.grid)\n    # Contruct the SPG-style cell tuple\n    # https://spglib.readthedocs.io/en/stable/python-interface.html#crystal-structure-cell\n    mapping = {\n        element: i + 1 for i, element in enumerate(set(self.primitive.symbols))\n    }\n    zs = [mapping[element] for element in self.primitive.symbols]\n    cell = (\n        tuple(map(tuple, self.primitive.cell.tolist())),\n        tuple(map(tuple, self.primitive.scaled_positions.tolist())),\n        tuple(zs),\n    )\n    # Get irr q-points\n    # TODO: cell = primitive.totuple()\n    mapping, all_qpoints = spglib.get_ir_reciprocal_mesh(\n        grid, cell, is_shift=np.zeros(3), symprec=1e-5\n    )\n    irr_qpoints = np.array([all_qpoints[idx] / grid for idx in np.unique(mapping)])\n\n    # Sort by (z, y, x) for consistency\n    return irr_qpoints[np.lexsort(irr_qpoints.T)]\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.to_toml","title":"<code>to_toml(output_file)</code>","text":"<p>Write the supercell data to a TOML file.</p> <ul> <li>output_file: str     The output file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def to_toml(self, output_file):\n    \"\"\"\n    Write the supercell data to a TOML file.\n\n    Parameters:\n    - output_file: str\n        The output file path.\n    \"\"\"\n    doc = tomlkit.document()\n    doc.add(\"primitive\", self._atoms_to_toml())\n    doc.add(\"brillouin_zone\", self._bz_to_toml())\n    doc.add(\"supercells\", self._supercells_to_toml())\n\n    with open(output_file, \"w\") as f:\n        f.write(doc.as_string())\n    print(f\"Supercells written to {output_file}\")\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.from_toml","title":"<code>from_toml(input_file)</code>  <code>classmethod</code>","text":"<p>Read the supercell data from a TOML file.</p> <ul> <li>input_file: str     The input file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>@classmethod\ndef from_toml(cls, input_file: str):\n    \"\"\"\n    Read the supercell data from a TOML file.\n\n    Parameters:\n    - input_file: str\n        The input file path.\n    \"\"\"\n\n    with open(input_file, \"rb\") as f:\n        data = tomli.load(f)\n\n    primitive = cls.atoms_from_toml(data[\"primitive\"])\n    bz = data[\"brillouin_zone\"]\n    grid = bz[\"grid\"]\n    irr_q = np.array(bz[\"irreducible_q\"])\n\n    if \"supercells\" in data:\n        supercells = data[\"supercells\"]\n        T_matrices = np.array([sc[\"matrix\"] for sc in supercells])\n        sc_size = np.array([sc[\"size\"] for sc in supercells])\n        comm_q = [np.array(sc[\"commensurate_q\"]) for sc in supercells]\n    else:\n        T_matrices = None\n        sc_size = None\n        comm_q = None\n    return cls(primitive, grid, irr_q, T_matrices, sc_size, comm_q)\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.atoms_from_toml","title":"<code>atoms_from_toml(data)</code>  <code>staticmethod</code>","text":"<p>Reconstructs a PhonopyAtoms object from TOML data.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>@staticmethod\ndef atoms_from_toml(data: dict) -&gt; PhonopyAtoms:\n    \"\"\"Reconstructs a PhonopyAtoms object from TOML data.\"\"\"\n    return PhonopyAtoms(\n        symbols=data[\"species\"],\n        scaled_positions=np.array(data[\"frac_coords\"]),\n        cell=np.array(data[\"lattice\"]),\n    )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.generate_supercells","title":"<code>generate_supercells(minkowski_reduce=True, minimize_supercells=False)</code>","text":"<p>Generate nondiagonal supercells commensurate with the IBZ.</p> <ul> <li>reduce: bool     Whether to Minkowski reduce the supercells (default: True, recommended).</li> <li>trim: bool     Whether to trim the supercells using ILP (default: False, broken).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def generate_supercells(\n    self, minkowski_reduce: bool = True, minimize_supercells: bool = False\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate nondiagonal supercells commensurate with the IBZ.\n\n    Parameters:\n    - reduce: bool\n        Whether to Minkowski reduce the supercells (default: True, recommended).\n    - trim: bool\n        Whether to trim the supercells using ILP (default: False, broken).\n    \"\"\"\n\n    self.sc_matrices = self._get_ndsc_matrices()\n    if minkowski_reduce:\n        self.sc_matrices = np.array(\n            [minkowski_reduce_sc(T, self.primitive.cell) for T in self.sc_matrices]\n        )\n\n    self.sc_sizes = np.array([np.linalg.det(T) for T in self.sc_matrices])\n    self.q_comm = [\n        np.array([q for q in self.q_ibz if np.allclose(np.rint(T @ q), T @ q)])\n        for T in self.sc_matrices\n    ]\n\n    if minimize_supercells:\n        print(\n            f\"We have {len(self.sc_matrices)} q-points in IBZ necessitating \"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{np.sum(self.sc_sizes)}\"\n        )\n        self._pick_smallest_supercells()\n        print(\n            f\"After minimization, we only need\"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{np.sum(self.sc_sizes)}\"\n        )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.convert_to_fraction_array","title":"<code>convert_to_fraction_array(arr)</code>","text":"<p>Takes a numpy array of floats and converts them to fractions.</p> <p>The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def convert_to_fraction_array(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Takes a numpy array of floats and converts them to fractions.\n\n    The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.\n    \"\"\"\n    result = np.empty((arr.shape[0], 2, arr.shape[1]), dtype=int)\n\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            frac = Fraction(arr[i, j]).limit_denominator()\n            result[i, 0, j] = frac.numerator\n            result[i, 1, j] = frac.denominator\n\n    return result\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_integers","title":"<code>find_integers(nums, g23, g12, g31, g123)</code>","text":"<p>Compute integers for off-diagonal supercell matrix elements Called by find_nondiagonal()</p> <p>This function is copied from QEPlayground</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_integers(nums, g23, g12, g31, g123):\n    \"\"\"\n    Compute integers for off-diagonal supercell matrix elements\n    Called by find_nondiagonal()\n\n    This function is copied from QEPlayground\n    \"\"\"\n    # Compute p (it's a modulo equation)\n    if g23 == 1:\n        p = 0\n    else:\n        for i in range(1, g23):\n            if (nums[1] + i * nums[2]) % g23 == 0:\n                p = i\n                break\n        # Compute q\n    g12_r = int(g12 / g123)\n    g23_r = int(g23 / g123)\n    g31_r = int(g31 / g123)\n    if g12_r == 1:\n        q = 0\n    else:\n        for i in range(1, g12_r):\n            if (g23_r * nums[0] + i * g31_r * nums[1]) % g12_r == 0:\n                q = i\n                break\n    # Compute r\n    gg_r = int(g31 * g23 / g123)\n    z = g23 * nums[0] / g12 + g31 * q * nums[1] / g12\n    if gg_r == 1:\n        r = 0\n    else:\n        for i in range(1, gg_r):\n            if (z + i * nums[2]) % gg_r == 0:\n                r = i\n                break\n    return p, q, r\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_nondiagonal","title":"<code>find_nondiagonal(Q)</code>","text":"<p>Nondiagonal supercell, based on [Phys. Rev. B 92, 184301] This function is copied from QEPlayground</p> <p>Parameters:</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_nondiagonal(Q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Nondiagonal supercell, based on [Phys. Rev. B 92, 184301]\n    This function is copied from QEPlayground\n\n    Parameters:\n    \"\"\"\n    # Take care of components already at Gamma\n    Q[1, np.where(Q[0] == 0)] = 1\n    # Shift the q-point into the positive quadrant of the reciprocal unit cell\n    Q[0, np.where(Q[0] &lt; 0)] += Q[1, np.where(Q[0] &lt; 0)]\n    # GCDs of Q[1] (in the logical order of the derivation)\n    g23 = math.gcd(Q[1, 1], Q[1, 2])\n    g12 = math.gcd(Q[1, 0], Q[1, 1])\n    g31 = math.gcd(Q[1, 2], Q[1, 0])\n    g123 = math.gcd(Q[1, 0], math.gcd(Q[1, 1], Q[1, 2]))\n    # Integers needed to solve the supercell matrix equation\n    p, q, r = find_integers(Q[0], g23, g12, g31, g123)\n    # Matrix elements (in order of derivation) and supercell matrix\n    S_33 = Q[1, 2]\n    S_22 = Q[1, 1] / g23\n    S_23 = p * Q[1, 2] / g23\n    S_11 = g123 * Q[1, 0] / (g12 * g31)\n    S_12 = q * g123 * Q[1, 1] / (g12 * g23)\n    S_13 = r * g123 * Q[1, 2] / (g31 * g23)\n    return np.array([[S_11, S_12, S_13], [0, S_22, S_23], [0, 0, S_33]])\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.minkowski_reduce_sc","title":"<code>minkowski_reduce_sc(T, lattice)</code>","text":"<p>Reduce a supercell matrix using Minkowski reduction.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>ndarray</code> <p>Supercell matrix.</p> required <code>lattice</code> <code>ndarray</code> <p>Primitive lattice.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def minkowski_reduce_sc(T, lattice):\n    \"\"\"\n    Reduce a supercell matrix using Minkowski reduction.\n\n    Args:\n        T (numpy.ndarray): Supercell matrix.\n        lattice (numpy.ndarray): Primitive lattice.\n\n    Returns:\n        numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.\n    \"\"\"\n    ndsc_lattice = np.dot(T, lattice)\n    ndsc_lattice = mink_reduce(ndsc_lattice)\n    T = np.dot(\n        ndsc_lattice,\n        np.linalg.inv(lattice),\n    )\n    return make_positive_det(np.rint(T).astype(int))\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.make_positive_det","title":"<code>make_positive_det(matrix)</code>","text":"<p>If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Input square matrix.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Adjusted matrix.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def make_positive_det(matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.\n\n    Args:\n        matrix (numpy.ndarray): Input square matrix.\n\n    Returns:\n        numpy.ndarray: Adjusted matrix.\n    \"\"\"\n    if np.linalg.det(matrix) &lt; 0:\n        # Find the row index with the most negative entries\n        negative_sums = np.sum(np.minimum(matrix, 0), axis=1)\n        row_to_flip = np.argmin(negative_sums)\n        matrix[row_to_flip] *= -1\n\n    return matrix\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce","title":"<code>mink_reduce(vecs, tol=1e-07, max_iter=100)</code>","text":"<p>Perform Minkowski reduction on a set of 3 vectors in 3D space.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row represents a 3D vector. tol : float, optional     Tolerance for floating-point comparisons, default is 1e-7. max_iter : int, optional     Maximum number of iterations, default is 100.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--returns","title":"Returns","text":"<p>np.ndarray     Minkowski-reduced vectors.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def mink_reduce(vecs: np.ndarray, tol: float = 1e-7, max_iter: int = 100) -&gt; np.ndarray:\n    \"\"\"\n    Perform Minkowski reduction on a set of 3 vectors in 3D space.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row represents a 3D vector.\n    tol : float, optional\n        Tolerance for floating-point comparisons, default is 1e-7.\n    max_iter : int, optional\n        Maximum number of iterations, default is 100.\n\n    Returns\n    -------\n    np.ndarray\n        Minkowski-reduced vectors.\n    \"\"\"\n    if vecs.shape != (3, 3):\n        raise ValueError(\"Input must have shape (3, 3).\")\n\n    i = 0\n    while True:\n        # Keep track of whether any reduction occurred\n        changed = False\n\n        for i in range(3):\n            temp_vecs = vecs.copy()\n            temp_vecs[i] = 0.0  # Temporarily zero out the i-th vector\n            reduced_vecs = reduce_vectors(temp_vecs, tol)\n            reduced_vecs[i] = vecs[i]  # Restore the i-th vector\n\n            if not np.allclose(reduced_vecs, vecs):\n                vecs = reduced_vecs\n                changed = True\n                break\n\n        # Check combinations involving all three vectors\n        if not changed:\n            reduced_vecs = reduce_vectors(vecs, tol)\n            if not np.allclose(reduced_vecs, vecs, atol=tol, rtol=0):\n                vecs = reduced_vecs\n                continue\n\n        # Stop if no changes occurred in this iteration\n        if not changed:\n            break\n\n        i += 1\n        if i &gt; max_iter:\n            raise RuntimeError(\"Too many iterations in Minkowski reduction.\")\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors","title":"<code>reduce_vectors(vecs, tol)</code>","text":"<p>Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row is a 3D vector. tol : float     Tolerance for floating-point comparisons.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--returns","title":"Returns","text":"<p>np.ndarray     A new array with the reduced vectors if a reduction occurs, or the original array unchanged.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def reduce_vectors(vecs: np.ndarray, tol: float) -&gt; np.ndarray:\n    \"\"\"\n    Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row is a 3D vector.\n    tol : float\n        Tolerance for floating-point comparisons.\n\n    Returns\n    -------\n    np.ndarray\n        A new array with the reduced vectors if a reduction occurs, or the original array unchanged.\n    \"\"\"\n    lengths_sq = np.sum(vecs**2, axis=1)\n    longest_idx = np.argmax(lengths_sq)\n    max_len_sq = lengths_sq[longest_idx]\n\n    a, b, c = vecs\n    candidates = [\n        a + b - c,\n        a - b + c,\n        -a + b + c,\n        a + b + c,\n    ]\n\n    for candidate in candidates:\n        if np.dot(candidate, candidate) &lt; max_len_sq * (1 - tol):\n            new_vecs = vecs.copy()\n            new_vecs[longest_idx] = candidate\n            return new_vecs\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/symmetries/","title":"symmetries","text":""},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer","title":"<code>Symmetrizer(primitive, threshold=1e-05)</code>","text":"<p>The constructor takes the pymatgen Structure object and sets up attributes in a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.</p> <p>Parameters:</p> Name Type Description Default <code>primitive</code> <code>Primitive</code> <p>The primitive cell of the structure</p> required <code>Threshold</code> <p>Numerical threshold for symmetry detection, defaults to 1e-5.</p> required Source code in <code>quesadilla/symmetries.py</code> <pre><code>def __init__(\n    self,\n    primitive: Primitive,\n    threshold: float = 1e-5,\n):\n    \"\"\"Initialize a symmetry analysis object for a structure.\n\n    The constructor takes the pymatgen Structure object and sets up attributes in\n    a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO\n    symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.\n\n    Args:\n        primitive: The primitive cell of the structure\n        Threshold: Numerical threshold for symmetry detection, defaults to 1e-5.\n    \"\"\"\n\n    # Define QE Variables with fortran-ready data types\n    # NOTE: we use the same names as the QE Fortran routines\n    # self.nat = np.intc(len(structure))  # Number of atoms\n    self.nat = np.intc(len(primitive))  # Number of atoms\n    # assert self.nat == self.nat2, \"Number of atoms do not match\"\n    # s(:,:,i) is the i-th symmetry operation. Zeros for missing symmetries\n    self.s = np.zeros((3, 3, 48), dtype=np.intc, order=\"F\")\n    # irt(i,j) is the index of the atom you get from applying symmetry i to atom j\n    self.irt = np.zeros((48, self.nat), dtype=np.intc, order=\"F\")\n    # Array with index of inverse symmetry of each operation\n    self.invs = np.zeros((48), dtype=np.intc, order=\"F\")\n    # Array with S.r_a - r_a for each symm op and atom a\n    self.rtau = np.zeros((3, 48, self.nat), dtype=np.float64, order=\"F\")\n    # ft(:, j) is the fractional translation of symmetry j in FRAC coords\n    self.ft = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the crystal\n    self.nsym = np.intc(0)\n    # Number of symmetries in the Bravais lattice\n    self.nrot = np.intc(0)\n\n    # Whether there is a symm op S_{-} such that S_{-} . q = -q + G\n    self.minus_q = np.array([True], dtype=np.intc)\n    # s(:, :, irotmq) is the symmetry operation that maps q to -q + G\n    self.irotmq = np.intc(0)\n    # This is the G vector in S_{-} . q = -q + G\n    self.gimq = np.zeros((3), dtype=np.float64, order=\"F\")\n    # gi(:, i) is the G vector in S(:,:,i)@q = q + G\n    self.gi = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the star of a q-point\n    self.nsymq = np.intc(0)\n\n    # Assign unique number to each species\n    mapping = {element: i + 1 for i, element in enumerate(set(primitive.symbols))}\n    self.ityp = np.array(\n        [mapping[element] for element in primitive.symbols], dtype=np.intc\n    )\n    # Atoms' cartesian coordinates\n    self.tau = primitive.positions.T\n    # # Lattice vectors (QE routines expect columns as basis vectors)\n    self.at = np.array(primitive.cell.T, dtype=np.float64, order=\"F\")\n    # Reciprocal lattice vectors/(2pi) (QE routines expect columns as basis vectors)\n    recip_lattice = np.linalg.inv(primitive.cell).T * (2 * np.pi)\n    self.bg = np.array(recip_lattice.T / (2 * np.pi), dtype=np.float64, order=\"F\")\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_xq_from_aq","title":"<code>get_xq_from_aq(aq)</code>","text":"<p>Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>aq</code> <p>ndarray(3) The q-point in fractional coordinates.</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_xq_from_aq(self, aq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.\n\n    Parameters:\n        - aq : ndarray(3)\n            The q-point in fractional coordinates.\n\n    Returns:\n        ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n    \"\"\"\n    return np.dot(aq, self.bg.T)\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_aq_from_xq","title":"<code>get_aq_from_xq(xq)</code>","text":"<p>Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in fractional coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_aq_from_xq(self, xq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).\n\n    Parameters:\n        - xq : ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n\n    Returns:\n        ndarray(3)\n            The q-point in fractional coordinates.\n    \"\"\"\n    return np.dot(xq, np.linalg.inv(self.bg.T))\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_star_q","title":"<code>get_star_q(xq, verbose=False, debug=False)</code>","text":"<p>Get the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3), q point in CARTESIAN coordinates / (2 * pi)</p> required <code>-</code> <code>verbose</code> <p>bool Whether to print the number of q-points in the star and the list of q-points in the star.</p> required <code>-</code> <code>debug</code> <p>bool Whether to print debug information from Fortran routines.</p> required <p>Returns:</p> Type Description <p>ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_star_q(self, xq: ArrayLike, verbose: bool = False, debug: bool = False):\n    # sourcery skip: extract-method\n    \"\"\"\n    Get the star of a q-point.\n\n    Parameters:\n        - xq : ndarray(3), q point in CARTESIAN coordinates / (2 * pi)\n        - verbose : bool\n            Whether to print the number of q-points in the star and the list of q-points in the star.\n        - debug : bool\n            Whether to print debug information from Fortran routines.\n\n    Returns:\n        ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)\n    \"\"\"\n    # To get the star we need the symmetries of the WHOLE CRYSTAL\n    # So that's just the litle group of the Gamma point\n    self._setup_little_group(np.array([0, 0, 0]), verbose)\n    # Return values are:\n    # 1. number of q-points in the star\n    # 2. The vector that q is mapped to under each symmop\n    # 3. Index of q in sxq\n    # 4. Index of -q in sxq, 0 if not present\n    self.nqs, self.sxq, self.isq, self.imq = espresso_symm.star_q(\n        xq,  # q point in cartesian coordinates/2pi\n        self.at,  # lattice vectors (see __init__ for format)\n        self.bg,  # rec. lattice vectors (see __init__ for format)\n        self.nsym,  # Number of symmetries in the small group of q\n        self.s,  # Array of ALL symmetries of the crystal\n        self.invs,  # Index of inverse of s in self.s\n        False,  # Debug flag\n    )\n    star_xq = self.sxq[:, : self.nqs].T\n    if verbose:\n        q_star = np.array([self.get_aq_from_xq(xqs) for xqs in star_xq])\n        print(\"Number of q in the star:\", self.nqs)\n        print(\"List of q in the star:\")\n        for i, qq in enumerate(q_star):\n            print(f\"{i+1}    {np.round(qq, 8)}\")\n        if self.imq == 0:\n            print(\"In addition, there is the -q list, which is NOT in the star:\")\n            for i, qq in enumerate(q_star):\n                print(f\"{i+1+self.nqs}    {np.round(qq, 8)}\")\n        else:\n            mq = self.get_aq_from_xq(self.sxq[:, self.imq - 1])  # -q\n            gmq = self.get_aq_from_xq(self.gimq)  # G\n            q = self.get_aq_from_xq(xq)  # q\n            print(\"-q is also in the star: \", np.round(mq, 8))\n            print(\"With G = \", np.round(gmq, 8))\n            print(\"So that S_ @ q - (-q + G)\", np.round(mq + q - gmq, 5))\n\n    return star_xq\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.symmetrize_fcq","title":"<code>symmetrize_fcq(fcq, xq, verbose=False)</code>","text":"<p>Symmetrize the force constants at a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in CARTESIAN coordinates / (2 * pi)</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>(3 * nat, 3 * nat)</code> <p>The symmetrized force constants at q in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def symmetrize_fcq(self, fcq: ArrayLike, xq: ArrayLike, verbose: bool = False):\n    \"\"\"\n    Symmetrize the force constants at a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in CARTESIAN coordinates / (2 * pi)\n\n    Returns:\n        ndarray(3 * nat, 3* nat): The symmetrized force constants at q in FRACTIONAL coordinates.\n    \"\"\"\n    self._setup_little_group(xq, verbose)\n    return espresso_symm.symdynph_gq_new(\n        xq,\n        self.at,\n        self.bg,\n        fcq,\n        self.s,\n        self.invs,\n        self.rtau,\n        self.irt,\n        self.nsymq,\n        self.irotmq,\n        self.minus_q,\n    )\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_fcq_in_star","title":"<code>get_fcq_in_star(fcq, aq, verbose=True)</code>","text":"<p>Get the force constants in the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), Fourier-transformed force constants         in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in FRACTIONAL coordinates</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3nat x 3nat matrix in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_fcq_in_star(self, fcq, aq, verbose=True):\n    \"\"\"\n    Get the force constants in the star of a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), Fourier-transformed force constants\n                    in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in FRACTIONAL coordinates\n\n    Returns:\n        dict: The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3*nat x 3*nat matrix in FRACTIONAL coordinates.\n    \"\"\"\n\n    # Symmetrize the force constants at q\n    aq = np.array(aq, dtype=np.float64, order=\"F\")\n    xq = self.get_xq_from_aq(aq)\n    fcq = np.array(fcq, dtype=np.complex128, order=\"F\")\n    fcq_symm = self.symmetrize_fcq(fcq, xq, verbose)\n\n    # Get star of the q-point\n    star_xq = self.get_star_q(xq, verbose)\n    # In the special case that -q is NOT in the star,\n    # We compute the FCQ at -q anyway using TRS and include it\n    if self.imq == 0:\n        nq_tot = 2 * self.nqs\n        star_xq = np.concatenate((star_xq, -star_xq), axis=0)\n    else:\n        nq_tot = self.nqs\n\n    # Get the FC(q) in the star\n    fcq_star = espresso_symm.q2qstar_ph(\n        fcq_symm,\n        self.at,\n        self.bg,\n        self.nsym,\n        self.s,\n        self.invs,\n        self.irt,\n        self.rtau,\n        self.nqs,\n        self.sxq,\n        self.isq,\n        self.imq,\n        nq_tot,\n    )\n\n    # Turn into a dictionary\n    final_fcq = {}\n    for i, xqq in enumerate(star_xq):\n        qq = self.get_aq_from_xq(xqq)\n        final_fcq[tuple(qq)] = fcq_star[i, :, :]\n\n    return final_fcq\n</code></pre>"},{"location":"reference/quesadilla/utils/","title":"utils","text":""},{"location":"reference/quesadilla/utils/#quesadilla.utils.write_lwm","title":"<code>write_lwm(prim, grid, path)</code>","text":"<p>Writes the lattice matrix, irreducible q-points, and grid to files suitable for input to Lloyd-Williams and Monserrat's code.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <code>Structure</code> <p>The primitive structure.</p> required <code>grid</code> <code>list</code> <p>The grid of q-points.</p> required <code>path</code> <code>str</code> <p>The directory to write the files to.</p> required Source code in <code>quesadilla/utils.py</code> <pre><code>def write_lwm(prim, grid, path):\n    \"\"\"\n    Writes the lattice matrix, irreducible q-points, and grid to files\n    suitable for input to Lloyd-Williams and Monserrat's code.\n\n    Args:\n        prim (pymatgen.Structure): The primitive structure.\n        grid (list): The grid of q-points.\n        path (str): The directory to write the files to.\n    \"\"\"\n    sga = SpacegroupAnalyzer(prim)\n    q_irr = sga.get_ir_reciprocal_mesh(grid)\n    q_irr = np.array([q[0] for q in q_irr])\n    # Write lattice matrix to path/prim.dat\n    np.savetxt(f\"{path}/prim.dat\", prim.lattice.matrix, fmt=\"%.10f\")\n    # Write irreducible q-points to path/ibz.dat\n    np.savetxt(f\"{path}/ibz.dat\", q_irr, fmt=\"%.10f\")\n    # Write grid to path/grid.dat\n    np.savetxt(f\"{path}/grid.dat\", np.array(grid), fmt=\"%d\", newline=\" \")\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.read_lwm","title":"<code>read_lwm(path)</code>","text":"<p>Reads kpoint_to_supercell.dat and associated supercell files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the directory containing kpoint_to_supercell.dat and supercell..dat files. required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def read_lwm(path):\n    \"\"\"\n    Reads kpoint_to_supercell.dat and associated supercell files.\n\n    Args:\n        path (str): Path to the directory containing kpoint_to_supercell.dat and supercell.&lt;i&gt;.dat files.\n\n    Returns:\n        tuple: A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).\n    \"\"\"\n    # File paths\n    kpoint_file = os.path.join(path, \"kpoint_to_supercell.dat\")\n\n    # Read kpoint_to_supercell.dat using NumPy\n    kpoint_data = np.loadtxt(kpoint_file)\n\n    # Extract vectors (first 3 columns) and indices (last column)\n    q = kpoint_data[:, :3]\n    indices = kpoint_data[:, 3].astype(int)\n\n    # Read the associated supercell matrices\n    matrices = []\n    for i in indices:\n        supercell_file = os.path.join(path, f\"supercell.{i}.dat\")\n        T = np.loadtxt(supercell_file, dtype=int)  # Read the 3x3 matrix\n        matrices.append(make_positive_det(T))\n        # for qq in q:\n        qq = q[i - 1]\n        assert np.allclose(\n            T @ qq, np.round(T @ qq)\n        ), \"Supercell {i} is not commensurate with q = {qq}\"\n\n    return np.array(matrices), np.array(q)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.get_KPOINTS","title":"<code>get_KPOINTS(struct, kspace)</code>","text":"<p>TODO: switch to autoGR Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5. Parameters:</p> <p>struct : pymatgen.Structure     The structure object. kspace : float     The spacing of the k-point mesh in 1/\u00c5. Returns:</p> <p>kpoints : pymatgen.io.vasp.inputs.Kpoints     The KPOINTS object.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def get_KPOINTS(struct, kspace):\n    \"\"\"\n    TODO: switch to autoGR\n    Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5.\n    Parameters:\n    -----------\n    struct : pymatgen.Structure\n        The structure object.\n    kspace : float\n        The spacing of the k-point mesh in 1/\u00c5.\n    Returns:\n    --------\n    kpoints : pymatgen.io.vasp.inputs.Kpoints\n        The KPOINTS object.\n    \"\"\"\n    assert kspace &gt; 0, \"argument kspace must not be negative\"\n    b = np.array(struct.lattice.reciprocal_lattice.matrix)\n    N = np.maximum(\n        np.array([1, 1, 1]), np.round(np.sqrt(np.sum(b**2, axis=1)) / kspace)\n    ).astype(np.int64)\n    k_dict = {\n        \"nkpoints\": 0,\n        \"generation_style\": \"Gamma\",\n        \"kpoints\": [[N[0], N[1], N[2]]],\n        \"usershift\": [0, 0, 0],\n        \"comment\": f\"Mesh with spacing {kspace} 1/\u00c5\",\n    }\n    return Kpoints.from_dict(k_dict)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.generate_files","title":"<code>generate_files(primitive_filename, grid, k_spacing=0.15, verbose=False)</code>","text":"<p>Generates the files for an NDSC phonon calculation.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def generate_files(\n    primitive_filename: str, grid: list, k_spacing: float = 0.15, verbose: bool = False\n):\n    \"\"\"\n    Generates the files for an NDSC phonon calculation.\n    \"\"\"\n\n    root = os.path.dirname(primitive_filename)\n    primitive = get_phonopy_prim(primitive_filename)\n    sc_gen = SupercellGenerator(primitive, grid)\n    sc_gen.generate_supercells()\n\n    # pymatgen structure object\n    new_prim_filename = os.path.join(root, \"POSCAR_standard_primitive\")\n    prim = Structure.from_file(new_prim_filename)\n\n    T_matrices, sc_size, comm_q = sc_gen.sc_matrices, sc_gen.sc_sizes, sc_gen.q_comm\n    for i, (T, sz, q) in enumerate(zip(T_matrices, sc_size, comm_q)):\n        # Print the supercell information\n        if verbose:\n            print(\n                (\n                    f\"Supercell {i+1} with size {sz} is commensurate with q = \"\n                    f\"{np.round(q, 3)}\"\n                )\n            )\n            print(\"Supercell matrix:\")\n            print(T)\n        # Generate the supercell\n        sc_path = os.path.join(root, f\"sc-{i+1}\")\n        os.makedirs(sc_path, exist_ok=True)\n        sc = prim.copy()\n        sc.make_supercell(T)\n        prim.to(filename=os.path.join(sc_path, \"POSCAR\"), fmt=\"poscar\")\n        sc.to(filename=os.path.join(sc_path, \"quesadilla_ndsc.vasp\"), fmt=\"poscar\")\n        get_KPOINTS(sc, k_spacing).write_file(os.path.join(sc_path, \"KPOINTS\"))\n\n        # DIM string uses supercell matrix, flattened. Phonopy uses transpose\n        T_str = \" \".join([f\"{int(x):d}\" for x in T.T.flatten()])\n        with open(os.path.join(sc_path, \"make_disp.conf\"), \"w\") as f:\n            f.write(MAKE_DISP.format(T_str))\n        with open(os.path.join(sc_path, \"get_yaml.conf\"), \"w\") as f:\n            f.write(GET_YAML.format(T_str))\n    sc_gen.to_toml(os.path.join(root, \"quesadilla.toml\"))\n</code></pre>"},{"location":"reference/tools/run_f2py/","title":"run_f2py","text":""}]}