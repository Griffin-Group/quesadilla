{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quesadilla","text":"<p>Quesadilla (Queue-saving nondiagonal superlattices) is a python package for nondiagonal supercell (NDSC) phonon calculations, using the approach of Lloyd-Williams and Monserrat. </p> <p>The nondiagonal supercell method can dramatically reduce the computational cost of phonon calculations. In the standard \"diagonal supercell\" approach (as implemented in, e.g., phonopy), sampling the dynamical matrix on an \\(N \\times N \\times N\\) \\(q\\)-grid requires calculating the forces in several \\(N \\times N \\times N\\) supercells, each with \\(N^3\\) as many atoms as the primitive cell. In the nondiagonal supercell approach, you only need the forces from supercells with \\(N\\)-times as many atoms as the primitive cell, leading to immense computational savings even for small systems.</p> <p>Quesadilla is designed to significantly simplify this process. It can generate all the NDSCs and generate the necessary displacements for each supercell. Once you have used your favorite force calculator to compute the forces (e.g., VASP), quesadilla can compute the force sets in the nondiagonal supercells and then construct the full force constant matrix in real space for the corresponding diagonal supercell. Quesadilla uses symmetry and other tricks to figure out the absolute minimum number of NDSCs that covers the irreducible part of your \\(q\\)-grid, then uses little-group symmetries to generate the dynamical matrix in the entire Brillouin zone and symmetrize it, giving you the full force constant matrix in the equivalent diagonal supercell at a fraction of the computational cost.</p> <p>Quesadilla is built as a layer on top of phonopy, so if you know how to use phonopy, you already know how to use Quesadilla. Further, quesadilla outputs <code>phonopy.yaml</code> files, so any workflows designed for phonopy will work flawlessly with quesadilla without any modification! Every force calculator supported by phonopy is supported by quesadilla as well. </p> <p>Under the hood, quesadilla uses <code>spglib</code> to handle much of the symmetry analysis, and a performant FORTRAN backend---adapted from Quantum ESPRESSO's PHonon routines---to deal with the symmetries of the dynamical matrix.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>A simple, phonopy-like interface for generating NDSCs and computing force constants.</li> <li>Supports all force calculators supported by phonopy (VASP, QE, Wien2k, etc.).</li> <li>Generates standard <code>phonopy.yaml</code> files that can be used with phonopy or any other package that reads phonopy output files.</li> <li>Heavily uses symmetry to minimize the computational cost of the calculations.</li> <li>Solves the set cover problem to extract the minimum number of NDSCs needed to cover the irreducible part of the \\(q\\)-grid.</li> </ul>"},{"location":"#to-be-implemented","title":"To be implemented","text":"<ul> <li>Magnetic systems.</li> <li>Expanded documentation and tutorials.</li> <li>Developer documentation.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Quesadilla requires a FORTRAN compiler and a BLAS/LAPACK installation on your path. It has only been tested on Linux and MacOS. The package is not yet listed on PyPI, so you need to install it directly from the GitHub repository via <code>pip</code>: <pre><code>pip install git+git@github.com:Griffin-Group/quesadilla.git\n</code></pre></p> <p>If you have any issues with the installation, please open an issue.</p> <p>On an Apple Silicon Mac, you may need to reinstall <code>phonopy</code> because it sometimes builds for the wrong architecture for some reason (not sure why...?). <pre><code>CMAKE_ARGS=\"-DCMAKE_OSX_ARCHITECTURES=arm64\" pip install --upgrade --verbose --force-reinstall --no-cache-dir phonopy\n</code></pre></p> <p>If you want to install the package in editable mode, it's slightly different from the usual approach because of the fortran extension.</p> <pre><code>pip install numpy meson meson-python\npython -m pip install --no-build-isolation --editable . \n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Quesadilla has a simple CLI that is nearly identical to phonopy. If you know how to use phonopy, you already know how to use Quesadilla! See the full tutorial for more details.</p> <p>To generate the NDSCs, you can run</p> <p><pre><code>quesadilla -d --dim 4 4 4\n</code></pre> which will find the smallest number of NDSCs that cover the irreducible part of a 4x4x4 \\(q\\)-grid. You can then use your favorite force calculator to compute the forces in these supercells, and then run</p> <p><pre><code>quesadilla -f vasprun.xml\n</code></pre> to create the <code>FORCE_SETS</code> file for each NDSC. Finally, you can compute the force constants in the full 4x4x4 supercell by running</p> <pre><code>quesadilla --fc\n</code></pre> <p>which will produce a <code>phonopy.yaml</code> file that can be used with phonopy or any other package that reads phonopy output files.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>In this short tutorial, we will work through the process of computing the phonon dispersion of Silicon on a \\(4 \\times 4 \\times 4\\) \\(q\\)-grid using the nondiagonal supercell (NDSC) method. We will use VASP as the force calculator, but the process is similar for every other DFT code supported by phonopy. We assume the reader is already familiar with phonopy and the basics of phonon calculations. </p> <p>The files for this tutorial are available in the <code>example</code> directory of the Quesadilla repository.</p>"},{"location":"tutorial/#step-1-generate-supercells-with-displacements","title":"Step 1: Generate supercells with displacements","text":"<p>The first step is always to generate supercells with displacements, and the Quesadilla command line interface is very similar to phonopy's. With phonopy, you would run something like <code>phonopy -d --dim 4 4 4</code>, perhaps with extra arguments (e.g., <code>phonopy --qe -d --dim 4 4 4 -c pw.in</code> for QE). Quesadilla supports all force calculators suppported by phonopy, as well as all the arguments used to control displacements (e.g., <code>--pm</code>, <code>--trigonal</code>, etc.)</p> <p>To generate NDSCs, you can run the exact same command you'd want to run with <code>phonopy</code>, but replace <code>phonopy</code> with <code>quesadilla</code>:</p> <p><pre><code># Assumes you use VASP and POSCAR is in current directory\nquesadilla -d --dim 4 4 4\n</code></pre> with output <pre><code>Standard primitive cell written to PPOSCAR\nWe have 8 q-points in IBZ necessitating 8 supercells with total size  25\nAfter minimization, we only need 5 supercells with total size  20\nSupercells written to quesadilla.toml\nWarning: Point group symmetries of supercell and primitivecell are different.\nNondiagonal supercell 1 needs 2 displacements.\nNondiagonal supercell 2 needs 2 displacements.\nNondiagonal supercell 3 needs 2 displacements.\nNondiagonal supercell 4 needs 4 displacements.\nNondiagonal supercell 5 needs 2 displacements.\n</code></pre> You can ignore the point group warnings, see this issue</p> <p>The directory structure after running this command should automatically look like this:</p> <pre><code>.\n\u251c\u2500\u2500 POSCAR\n\u251c\u2500\u2500 PPOSCAR\n\u251c\u2500\u2500 quesadilla.toml\n\u251c\u2500\u2500 sc-001\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-001\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-002\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SPOSCAR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 phonopy_disp.yaml\n\u251c\u2500\u2500 sc-002\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-001\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-002\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SPOSCAR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 phonopy_disp.yaml\n\u251c\u2500\u2500 sc-003\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-001\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-002\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SPOSCAR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 phonopy_disp.yaml\n\u251c\u2500\u2500 sc-004\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-001\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-002\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-003\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 POSCAR-004\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SPOSCAR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 phonopy_disp.yaml\n\u2514\u2500\u2500 sc-005\n    \u251c\u2500\u2500 POSCAR\n    \u251c\u2500\u2500 POSCAR-001\n    \u251c\u2500\u2500 POSCAR-002\n    \u251c\u2500\u2500 SPOSCAR\n    \u2514\u2500\u2500 phonopy_disp.yaml\n</code></pre> <p>What Queasdilla is doing under the hood</p> <p>In a conventional <code>phonopy</code> calculation, <code>phonopy -d --dim 4 4 4</code> would have produced a pristine 4x4x4 supercell file (e.g., <code>SPOSCAR</code>), some supercells with displacements (e.g., <code>POSCAR-00{1,2,3...}</code>) and a <code>phonopy_disp.yaml</code> in the current directory. With quesadilla, it's a little more involved. Under the hood, quesadilla is doing the following:</p> <ol> <li>First, <code>quesadilla</code> will find a standard primitive cell. This is similar to running <code>phonopy --symmetry</code>. This standard primitive cell is what will be used to build the nondiagonal supercell, and will be saved in a file <code>PPOSCAR</code> in the current directory.</li> <li>Next, quesadilla will figure out the minimum number of nondiagonal supercells necessary to span the 4x4x4 q-grid, build them, and then Minkowski reduce them. These files will be placed in the directories <code>sc-{001,002,...}</code>, each corresponding to a nondiagonal supercell. Each NDSC will be in, e.g., the <code>sc-*/SPOSCAR</code> file for VASP. The standard primitive file will also be placed in these directories as <code>POSCAR</code></li> <li>Next, quesadilla will generate the displacemnts in each of these supercells, producing the files <code>sc-*/POSCAR-*</code>. This would be similar to running <code>phonopy -d --dim &lt;ndsc matrix&gt;</code> on every single supercell. Each <code>sc-*</code> folder will also have a <code>phonopy_disp.yaml</code> file, which can be used for debugging if necessary, and will be read later when creating the force sets.</li> <li>Finally, a file <code>quesadilla.toml</code> will be written in the current, which contains all the information about the supercells and which \\(q\\)-points they are commensurate with. All subsequent commands will read this file.</li> </ol> <p>Why so many displacements?</p> <p>You'll notice that the 5 nondiagonal supercells have 2 displacements each, except for the 4th supercell, which has 4 displacements. If you run <code>phonopy -d --dim 4 4 4</code>, you'll only get one supercell with displacement. This is because the nondiagonal supercells have lower symmetry than diagonal supercells, so you need more displacements to get the force constant matrix. For Si on a \\(4 \\times 4 \\times 4\\) \\(q\\)-grid, a standard diagonal supercell calculation would require 1 DFT calcualtion for a supercell with 128 atoms, while the NDSC method requires a total of 12 DFT calculations for supercells with 8 atoms each. </p>"},{"location":"tutorial/#step-2-run-the-dft-calculations","title":"Step 2: run the DFT calculations","text":"<p>As usual with <code>phonopy</code>, we now have to run the DFT calculations on the supercells with the displacements. We will place each <code>POSCAR-xxx</code> in a directory <code>disp-xxx</code> and run the calculation there (e.g., <code>POSCAR-002</code> should go in a directory <code>disp-002</code>). While this directory structure is optional for phonopy, it is mandatory for quesadilla. This needs to be repeated for every single supercell (i.e., for each <code>sc-*</code> directory). Optionally, the forces in the pristine supercell can also be calculated so they can be subtracted from the force sets in the next step. If this is desired, the pristine supercell calculation (e.g., the <code>SPOSCAR</code> file) should be run in the <code>disp-000</code> folder.</p> <p>Be careful with \\(k\\)-points!</p> <p>With diagonal supercells, it's easy to choose the \\(k\\)-points for each DFT calculation in the supercell. For example, if your primitive cell was converged with an \\(8 \\times 8 \\times 8\\) \\(k\\)-grid, then a \\(4 \\times 4 \\times 4\\) supercell would have the same \\(k\\)-point density with a \\(2 \\times 2 \\times 2\\) grid instead.</p> <p>The situation is a little trickier with NDSCs and the \\(k\\)-grid used for each NDSC will be different. The easiest option is to use an external tool to generate necessary grid that maintains the desired \\(k\\)-point spacing. The script <code>example/generate_kpoints.py</code> shows how to do this with <code>pymatgen</code>. </p> <p>Also note that, given the lower symmetry and weird shape of NDSCs, you will sometimes see this warning in VASP:</p> <pre><code> -----------------------------------------------------------------------------\n|                                                                             |\n|           W    W    AA    RRRRR   N    N  II  N    N   GGGG   !!!           |\n|           W    W   A  A   R    R  NN   N  II  NN   N  G    G  !!!           |\n|           W    W  A    A  R    R  N N  N  II  N N  N  G       !!!           |\n|           W WW W  AAAAAA  RRRRR   N  N N  II  N  N N  G  GGG   !            |\n|           WW  WW  A    A  R   R   N   NN  II  N   NN  G    G                |\n|           W    W  A    A  R    R  N    N  II  N    N   GGGG   !!!           |\n|                                                                             |\n|     Your reciprocal lattice and k-lattice belong to different lattice       |\n|     classes:                                                                |\n|                                                                             |\n|        The reciprocal lattice is base-centered monoclinic,                  |\n|        whereas your k-lattice is triclinic.                                 |\n|                                                                             |\n|     Results are often still useful ...                                      |\n|                                                                             |\n-----------------------------------------------------------------------------\n</code></pre> <p>In general, this is not a problem, but it may be best to use something more efficient than Monkhorst-Pack grids for the NDSCs, such as autoGR</p>"},{"location":"tutorial/#step-3-generate-the-force-sets-force_sets","title":"Step 3: generate the force sets (<code>FORCE_SETS</code>)","text":"<p>Once the DFT calcualtions are done, we will need to generate the <code>FORCE_SETS</code> files, just as we would in <code>phonopy</code>. In phonopy, we would use something like <code>phonopy disp-00{1..4}/vasprun.xml</code> to read the forces from the <code>vasprun.xml</code> for the four supercells with displacements. Here, we have five nondiagonal supercells with varying numbers of displacements each. As mentioned earlier,  Quesadilla requires your calculations to be structured so that <code>sc-001/POSCAR-001</code> (and the resultant <code>vasprun.xml</code> or similar output file) go into the folder <code>sc-001/disp-001</code>, etc. To generate the <code>FORCE_SETS</code> for all supercells with <code>quesadilla</code>, we can run from the root directory</p> <pre><code>quesadilla -f vasprun.xml\n</code></pre> <p>which is similar to running <code>phonopy -f disp-*/vasprun.xml</code> in every <code>sc-*</code> directory, generating one <code>FORCE_SETS</code> file per supercell. The output should look like <pre><code>Working on supercell 1 in directory sc-001\nFound 2 displacements.\nFiles to extract forces from:\n['disp-001/vasprun.xml', 'disp-002/vasprun.xml']\nCalculator interface: vasp\nDisplacements were read from \"phonopy_disp.yaml\".\ncounter (file index): 1 2\n\"FORCE_SETS\" has been created.\n------------------------------------\n&lt;repeat until sc-005&gt;\n</code></pre></p> <p>If you want to use the <code>--force-sets-zero</code> option, subtracting the residual forces from the pristine supercell, then with quesadilla we'll run</p> <pre><code>quesadilla --force-sets-zero vasprun.xml\n</code></pre> <p>assuming the pristine supercell calculation was done in the <code>sc-*/disp-000</code> directories as explained in the previous section.</p>"},{"location":"tutorial/#step-4-generate-the-force-constants","title":"Step 4: generate the force constants","text":"<p>Finally, we need to generate the force constants. This step is often skipped in <code>phonopy</code> and it is common to use the <code>FORCE_SETS</code> file directly. The command is (from the root directory)</p> <p><pre><code>quesadilla --fc\n</code></pre> with output <pre><code>Forces and displacements were read from \"FORCE_SETS\".\nForce constants calculation using phonopy-traditional starts.\nMax drift of force constants: 0.000001 (xx) 0.000001 (zz)\n------------------------------------\n&lt;repeat for all supercells&gt;\n------------------------------------\nFound 5 dynamical matrices at q = [0. 0. 0.]\nFound 1 dynamical matrices at q = [0.25 0.   0.  ]\nFound 1 dynamical matrices at q = [0.5 0.  0. ]\nFound 1 dynamical matrices at q = [-0.25  0.25  0.  ]\nFound 2 dynamical matrices at q = [0.5 0.5 0. ]\nFound 1 dynamical matrices at q = [0.25 0.25 0.  ]\nFound 1 dynamical matrices at q = [0.5  0.25 0.  ]\nFound 1 dynamical matrices at q = [-0.25  0.5   0.25]\nCreating the Phonopy object...\nFourier transforming the force constants back to real space...\nFound 64 q-points in the full BZ\nRunning DynmatToForceConstants...\nApplying acoustic sum rules...\n</code></pre></p> <p>this will produce a <code>phonopy.yaml</code> file in the root directory, containing the real space force constants for a diagonal \\(4 \\times 4 \\times 4\\) supercell. This file can be used with <code>phonopy</code>, <code>phono3py</code>, or any other code that reads <code>phonopy.yaml</code> files.</p> <p>For example, to plot the band structure, we could simply run, from the root directory:</p> <pre><code>phonopy-load --band auto -p phonopy.yaml\n</code></pre> <p>What Queasdilla is doing under the hood</p> <p>When the <code>quesadilla --fc</code> command is run, Quesadilla will read the <code>quesadilla.toml</code> file and then do the following:</p> <ol> <li>Read the the force sets (<code>FORCE_SETS</code>) file in each <code>sc-*</code> directory, and compute the real-space force constants for each NDSC. The results are stored in <code>sc-*/phonopy.yaml</code>, which is useful for debugging.</li> <li>Next, for each NDSC, it will Fourier transform the real-space force constants at the \\(q\\)-points each supercell is commensurate with.</li> <li>If a \\(q\\)-point is commensurate with multiple cells (such as the \\(\\Gamma\\) point, commensurate with all of them), the dynamical matrix is averaged. We now have the dynamical matrix at every \\(q\\) point in the iredducible Brillouin zone.</li> <li>Next, quesadilla will symmetrize the Fourier-transformed dynamical matrix \\(D(q)\\), using the symmetries of the little group of each q-point. This can get rid of small symmetry breaking problems that can happen in NDSCs.</li> <li>Using the symmetrized dynamical matrices, Quesadilla will calculate the star of each q-point in the iredducible brillouin zone, then use the appropriate representations of the operators, as well as and time reversal symmetry if applicable, to compute the dynamical matrix at every point in the star of q.</li> <li>Once this is done, we now have the dynamical matrix in the full Brillouin zone. We can now Fourier transform it to real space to obtain the force constant matrix of a diagonal 4x4x4 supercell.</li> <li>Finally, quesadilla will apply the acoustic sum rules (ASR) to enforce translational symmetry. The final real-space IFC for the equivalent \\(4 \\times 4 \\times 4\\) diagonal supercell is written to <code>phonopy.yaml</code> in the root directory.</li> </ol> <p>If you would like to learn more about how this works, I would recommend starting with the Chapter 2.1 of Volume D of the International Tables for Crystallography.</p> <p>We can compare the results to a standard diagonal supercell calculation</p> <p></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>example<ul> <li>generate_kpoints</li> </ul> </li> <li>quesadilla<ul> <li>cli</li> <li>dynmat</li> <li>supercells</li> <li>symmetries</li> <li>utils</li> </ul> </li> <li>tools<ul> <li>run_f2py</li> </ul> </li> </ul>"},{"location":"reference/example/generate_kpoints/","title":"generate_kpoints","text":"<p>Simple script to generate a KPOINTS file for a given structure and k-point spacing.</p> Usage <p>python generate_kpoints.py  Example <p>python generate_kpoints.py Si/sc-001/SPOSCAR 0.15</p>"},{"location":"reference/example/generate_kpoints/#example.generate_kpoints.get_KPOINTS","title":"<code>get_KPOINTS(struct, kspace)</code>","text":"<p>Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5. Parameters:</p> <p>struct : pymatgen.Structure     The structure object. kspace : float     The spacing of the k-point mesh in 1/\u00c5. Returns:</p> <p>kpoints : pymatgen.io.vasp.inputs.Kpoints     The KPOINTS object.</p> Source code in <code>example/generate_kpoints.py</code> <pre><code>def get_KPOINTS(struct, kspace):\n    \"\"\"\n    Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5.\n    Parameters:\n    -----------\n    struct : pymatgen.Structure\n        The structure object.\n    kspace : float\n        The spacing of the k-point mesh in 1/\u00c5.\n    Returns:\n    --------\n    kpoints : pymatgen.io.vasp.inputs.Kpoints\n        The KPOINTS object.\n    \"\"\"\n    assert kspace &gt; 0, \"argument kspace must not be negative\"\n    b = np.array(struct.lattice.reciprocal_lattice.matrix)\n    N = np.maximum(\n        np.array([1, 1, 1]), np.round(np.sqrt(np.sum(b**2, axis=1)) / kspace)\n    ).astype(np.int64)\n    k_dict = {\n        \"nkpoints\": 0,\n        \"generation_style\": \"Gamma\",\n        \"kpoints\": [[N[0], N[1], N[2]]],\n        \"usershift\": [0, 0, 0],\n        \"comment\": f\"Mesh with spacing {kspace} 1/\u00c5\",\n    }\n    return Kpoints.from_dict(k_dict)\n</code></pre>"},{"location":"reference/quesadilla/","title":"quesadilla","text":""},{"location":"reference/quesadilla/cli/","title":"cli","text":"<p>Quesadilla command line interface</p>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.get_parser","title":"<code>get_parser()</code>","text":"<p>Return ArgumentParser instance.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def get_parser():\n    \"\"\"Return ArgumentParser instance.\"\"\"\n\n    parser = argparse.ArgumentParser(\n        description=\"Phonopy command-line-tool\", allow_abbrev=False\n    )\n\n    add_arguments_of_calculators(parser, calculator_info)\n\n    # GENERAL\n    parser.add_argument(\n        \"--config\",\n        dest=\"conf_filename\",\n        metavar=\"FILE\",\n        default=None,\n        help=\"Phonopy configuration file\",\n    )\n    parser.add_argument(\n        \"--loglevel\", dest=\"loglevel\", type=int, default=None, help=\"Log level\"\n    )\n    # TODO: implement magnetism\n    parser.add_argument(\n        \"--magmom\", nargs=\"+\", dest=\"magmoms\", default=None, help=\"Same as MAGMOM tag\"\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"store_true\",\n        default=None,\n        help=\"Print out smallest information\",\n    )\n    parser.add_argument(\n        \"--random-seed\",\n        dest=\"random_seed\",\n        type=int,\n        default=None,\n        help=\"Random seed by a 32 bit unsigned integer\",\n    )\n    parser.add_argument(\n        \"--tolerance\",\n        dest=\"symmetry_tolerance\",\n        type=float,\n        default=None,\n        help=\"Symmetry tolerance to search\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        dest=\"verbose\",\n        action=\"store_true\",\n        default=None,\n        help=\"Detailed information is shown.\",\n    )\n    parser.add_argument(\n        \"filename\",\n        nargs=\"*\",\n        help=(\n            \"Phonopy configure file. However if the file is recognized as \"\n            \"phonopy.yaml like file, this file is read as phonopy.yaml like file.\"\n        ),\n    )\n    ###################################\n    # MODE 1 : pre-process\n    ###################################\n    # -----------------------------\n    # Required in this mode\n    parser.add_argument(\n        \"-d\",\n        \"--displacement\",\n        dest=\"is_displacement\",\n        action=\"store_true\",\n        default=None,\n        help=\"Create supercells with displacements\",\n    )\n    parser.add_argument(\n        \"--dim\",\n        nargs=\"+\",\n        dest=\"supercell_dimension\",\n        default=None,\n        help=\"Same behavior as DIM tag\",\n    )\n    # ----------------------\n    # Good default is guessed depending on the calculator\n    parser.add_argument(\n        \"-c\",\n        \"--cell\",\n        dest=\"cell_filename\",\n        metavar=\"FILE\",\n        default=None,\n        help=\"Read unit cell\",\n    )\n    # Control of displacement pattern\n    parser.add_argument(\n        \"--amplitude\",\n        \"--amin\",\n        dest=\"displacement_distance\",\n        type=float,\n        default=None,\n        help=(\n            \"Distance of displacements and also minimum distance of displacements \"\n            \"in random displacements\"\n        ),\n    )\n    parser.add_argument(\n        \"--amax\",\n        dest=\"displacement_distance_max\",\n        type=float,\n        default=None,\n        help=\"Minimum distance of displacements in random displacements\",\n    )\n    parser.add_argument(\n        \"--nodiag\",\n        dest=\"is_nodiag\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set displacements parallel to axes\",\n    )\n    parser.add_argument(\n        \"--nosym\",\n        dest=\"is_nosym\",\n        action=\"store_true\",\n        default=None,\n        help=\"Symmetry is not imposed.\",\n    )\n    parser.add_argument(\n        \"--trigonal\",\n        dest=\"is_trigonal_displacements\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set displacements of all trigonal axes \",\n    )\n    parser.add_argument(\n        \"--pm\",\n        dest=\"is_plusminus_displacements\",\n        action=\"store_true\",\n        default=None,\n        help=\"Set plus minus displacements\",\n    )\n    # TODO: not sure how to deal with this one?\n    parser.add_argument(\n        \"--wien2k-p1\",\n        dest=\"is_wien2k_p1\",\n        action=\"store_true\",\n        default=None,\n        help=\"Assume Wien2k structs with displacements are P1\",\n    )\n\n    # MODE 2: post-process\n    # -----------------------------\n    # MODE 2.1: generate force sets\n    # -----------------------------\n    parser.add_argument(\n        \"-f\",\n        \"--force-sets\",\n        nargs=\"+\",\n        dest=\"create_force_sets\",\n        default=None,\n        help=\"Create FORCE_SETS\",\n    )\n    parser.add_argument(\n        \"--fz\",\n        \"--force-sets-zero\",\n        nargs=\"+\",\n        dest=\"create_force_sets_zero\",\n        default=None,\n        help=(\n            \"Create FORCE_SETS. disp.yaml in the current directory and \"\n            \"vapsrun.xml's for VASP or case.scf(m) for Wien2k as arguments \"\n            \"are required. The first argument is that of the perfect \"\n            \"supercell to subtract residual forces\"\n        ),\n    )\n    # -----------------------------\n    # MODE 2.2: generate force constants\n    # -----------------------------\n    # NOTE: this tag works differently from phonopy\n    parser.add_argument(\n        \"--fc\",\n        \"--force-constants\",\n        dest=\"create_force_constants\",\n        action=\"store_true\",\n        default=None,\n        help=(\n            \"Create FORCE_CONSTANTS from vaspurn.xml. \"\n            \"vasprun.xml has to be passed as argument.\"\n        ),\n    )\n    # Force constant symmetry\n    # Should be hijaked and applied only to last step (ND D(q) -&gt; DSC D(q))\n    # Individual steps should not use symmetry\n    parser.add_argument(\n        \"--no-fc-symmetry\",\n        \"--no-sym-fc\",\n        dest=\"fc_symmetry\",\n        action=\"store_false\",\n        default=None,\n        help=\"Do not symmetrize force constants\",\n    )\n    parser.add_argument(\n        \"--fc-spg-symmetry\",\n        dest=\"fc_spg_symmetry\",\n        action=\"store_true\",\n        default=None,\n        help=\"Enforce space group symmetry to force constants\",\n    )\n    parser.add_argument(\n        \"--fc-symmetry\",\n        \"--sym-fc\",\n        dest=\"fc_symmetry\",\n        action=\"store_true\",\n        default=None,\n        help=\"Symmetrize force constants\",\n    )\n\n    return parser\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_displacements","title":"<code>create_displacements(sc_gen, settings, cell_info, log_level)</code>","text":"<p>Create displacements.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def create_displacements(\n    sc_gen: SupercellGenerator,\n    settings: PhonopySettings,\n    cell_info: dict,\n    log_level: int,\n):\n    \"\"\"\n    Create displacements.\n    \"\"\"\n    if settings.displacement_distance is None:\n        displacement_distance = get_default_displacement_distance(settings.calculator)\n    else:\n        displacement_distance = settings.displacement_distance\n\n    nd_phonons = []\n    cell_info_ndsc = cell_info.copy()\n    for i, sc_matrix in enumerate(sc_gen.sc_matrices):\n        # NOTE: phonopy convention is transposed compared to PRB 92, 184301 (2015)\n        cell_info_ndsc[\"supercell_matrix\"] = sc_matrix.T\n        phonon = _init_phonopy(\n            settings, cell_info_ndsc, settings.symmetry_tolerance, log_level\n        )\n        phonon.generate_displacements(\n            distance=displacement_distance,\n            is_plusminus=settings.is_plusminus_displacement,\n            is_diagonal=settings.is_diagonal_displacement,\n            is_trigonal=settings.is_trigonal_displacement,\n            number_of_snapshots=settings.random_displacements,\n            random_seed=settings.random_seed,\n            max_distance=settings.displacement_distance_max,\n        )\n        if log_level:\n            print(\n                f\"Nondiagonal supercell {i+1} needs {len(phonon.supercells_with_displacements)} displacements.\"\n            )\n        nd_phonons.append(phonon)\n\n    return nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.write_ndsc_with_displacement","title":"<code>write_ndsc_with_displacement(nd_phonons, calculator, confs, optional_structure_info)</code>","text":"<p>Write supercells with displacements as structure files</p> <p>Parameters:</p> Name Type Description Default <code>nd_phonons</code> <code>list[Phonopy]</code> <p>list of Phonopy objects for each NDSC</p> required <code>calculator</code> <code>str</code> <p>force calculator (e.g., \"vasp\")</p> required <code>confs</code> <code>dict</code> <p>dictionary of configuration as strings</p> required <code>optional_structure_info</code> <code>tuple</code> <p>output of read_cell_info</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def write_ndsc_with_displacement(\n    nd_phonons: list[Phonopy],\n    calculator: str,\n    confs: dict,\n    optional_structure_info: tuple,\n):\n    \"\"\"\n    Write supercells with displacements as structure files\n\n    Args:\n        nd_phonons: list of Phonopy objects for each NDSC\n        calculator: force calculator (e.g., \"vasp\")\n        confs: dictionary of configuration as strings\n        optional_structure_info: output of read_cell_info\n    \"\"\"\n    units = get_default_physical_units(calculator)\n    for i, phonon in enumerate(nd_phonons):\n        os.makedirs(f\"sc-{i+1:03d}\", exist_ok=True)\n        os.chdir(f\"sc-{i+1:03d}\")\n        write_crystal_structure(\n            get_default_cell_filename(calculator),\n            phonon.primitive,\n            interface_mode=calculator,\n            optional_structure_info=optional_structure_info,\n        )\n        # Write supercells with displacements as structure files\n        write_supercells_with_displacements(\n            phonon.calculator,\n            phonon.supercell,\n            phonon.supercells_with_displacements,\n            optional_structure_info=optional_structure_info,\n            additional_info={\"supercell_matrix\": phonon.supercell_matrix},\n        )\n        # Write phonopy_disp.yaml\n        _write_phonopy_disp_yaml(phonon, confs, units)\n        os.chdir(\"..\")\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._write_phonopy_disp_yaml","title":"<code>_write_phonopy_disp_yaml(phonon, confs, units)</code>","text":"<p>Write phonopy_disp.yaml file</p> <p>Parameters:</p> Name Type Description Default <code>phonon</code> <code>Phonopy</code> <p>Phonopy object</p> required <code>confs</code> <code>dict</code> <p>dict</p> required <code>units</code> <code>dict</code> <p>dict</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def _write_phonopy_disp_yaml(phonon: Phonopy, confs: dict, units: dict):\n    \"\"\"\n    Write phonopy_disp.yaml file\n\n    Args:\n        phonon: Phonopy object\n        confs: dict\n        units: dict\n    \"\"\"\n    yaml_settings = {\n        \"force_sets\": False,\n        \"force_constants\": False,\n        \"born_effective_charge\": False,\n        \"dielectric_constant\": False,\n        \"displacements\": True,\n    }\n    confs[\"dim\"] = \" \".join(map(str, phonon.supercell_matrix.flatten().tolist()))\n    phpy_yaml = PhonopyYaml(\n        configuration=confs, physical_units=units, settings=yaml_settings\n    )\n    phpy_yaml.set_phonon_info(phonon)\n    with open(\"phonopy_disp.yaml\", \"w\") as w:\n        w.write(str(phpy_yaml))\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._write_final_phonopy_yaml","title":"<code>_write_final_phonopy_yaml(phonon, confs, units)</code>","text":"<p>Write the final phonopy.yaml file after force constants have been computed from all the NDSCs.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def _write_final_phonopy_yaml(phonon: Phonopy, confs: dict, units: dict):\n    \"\"\"\n    Write the final phonopy.yaml file after force constants have been\n    computed from all the NDSCs.\n    \"\"\"\n    yaml_settings = {\n        \"force_sets\": False,\n        \"force_constants\": True,\n        \"born_effective_charge\": False,\n        \"dielectric_constant\": False,\n        \"displacements\": False,\n    }\n    confs[\"dim\"] = \" \".join(map(str, phonon.supercell_matrix.flatten().tolist()))\n    phpy_yaml = PhonopyYaml(\n        configuration=confs, physical_units=units, settings=yaml_settings\n    )\n    phpy_yaml.set_phonon_info(phonon)\n    with open(\"phonopy.yaml\", \"w\") as w:\n        w.write(str(phpy_yaml))\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.initialize_quesadilla","title":"<code>initialize_quesadilla()</code>","text":"<p>Initialize Quesadilla command line interface.</p> <p>Returns:</p> Name Type Description <code>PhonopySettings</code> <p>Phonopy settings</p> <code>dict</code> <p>Configuration settings</p> <code>str</code> <p>Cell filename</p> <code>int</code> <p>Log level</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def initialize_quesadilla():\n    \"\"\"\n    Initialize Quesadilla command line interface.\n\n    Returns:\n        PhonopySettings: Phonopy settings\n        dict: Configuration settings\n        str: Cell filename\n        int: Log level\n    \"\"\"\n    parser = get_parser()\n    args = parser.parse_args()\n    # Set log level\n    log_level = 1\n    if args.verbose:\n        log_level = 2\n    if args.quiet:\n        log_level = 0\n    if args.loglevel is not None:\n        log_level = args.loglevel\n\n    argparse_control = {\n        \"fc_symmetry\": False,\n        \"is_nac\": False,\n        \"load_phonopy_yaml\": False,\n    }\n    settings, confs, cell_filename = _read_phonopy_settings(\n        args, argparse_control, log_level\n    )\n\n    # These defaults are set internally inside multiple phonopy routines\n    # But I want to have them here from the get-go\n    if settings.calculator is None:\n        settings.calculator = \"vasp\"\n    if cell_filename is None:\n        cell_filename = get_default_cell_filename(settings.calculator)\n    if settings.symmetry_tolerance is None:\n        settings.symmetry_tolerance = 1e-5\n\n    # Ensure settings are correct\n    if settings.create_displacements or settings.random_displacements:\n        if settings.supercell_matrix is None:\n            raise ValueError(\"Supercell matrix is required for displacements\")\n        if not np.all(\n            np.diag(np.diag(settings.supercell_matrix)) == settings.supercell_matrix\n        ):\n            raise ValueError(\n                \"Supercell matrix (--dim or DIM) must be diagonal.\"\n                \"This is the size of your q-grid.\"\n            )\n\n    return settings, confs, cell_filename, log_level\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_force_sets","title":"<code>create_force_sets(settings, log_level, forces_filename)</code>","text":"<p>Create force sets from the displacements for each nondiagonal supercell.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>PhonopySettings</code> <p>Phonopy settings</p> required <code>log_level</code> <code>int</code> <p>Log level</p> required <code>forces_filename</code> <code>str</code> <p>The name of the file to read the forces from. This is the single argument of --force-sets or --force-sets-zero. Then for each supercell in the directory sc-i, the files to read forces from are disp-i/forces_filename.</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def create_force_sets(\n    settings: PhonopySettings,\n    log_level: int,\n    forces_filename: str,\n):\n    \"\"\"\n    Create force sets from the displacements for each nondiagonal supercell.\n\n    Args:\n        settings (PhonopySettings): Phonopy settings\n        log_level (int): Log level\n        forces_filename (str): The name of the file to read the forces from. This is the single argument of --force-sets or --force-sets-zero. Then for each supercell in the directory sc-i, the files to read forces from are disp-i/forces_filename.\n    \"\"\"\n    sc_gen = SupercellGenerator.from_toml(\"quesadilla.toml\")\n    for i in range(len(sc_gen.sc_matrices)):\n        os.chdir(f\"sc-{i+1:03d}\")\n        if log_level &gt; 0:\n            print(f\"Working on supercell {i+1} in directory sc-{i+1:03d}\")\n        _set_filenames_for_forcesets(settings, log_level, forces_filename)\n        _create_FORCE_SETS_from_settings(\n            settings,\n            \"phonopy_disp.yaml\",\n            settings.symmetry_tolerance,\n            log_level,\n        )\n        if log_level &gt; 0:\n            print(\"------------------------------------\")\n        os.chdir(\"..\")\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._set_filenames_for_forcesets","title":"<code>_set_filenames_for_forcesets(settings, log_level, forces_filename)</code>","text":"<p>Sets the filenames for the forcesets. This is a helper function for create_forcesets. Sets settings.create_force_sets or settings.create_force_sets_zero to a list of files to read the forces from based on the <code>phonopy_disp.yaml</code> file.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def _set_filenames_for_forcesets(\n    settings: PhonopySettings, log_level: int, forces_filename: str\n):\n    \"\"\"\n    Sets the filenames for the forcesets. This is a helper function for create_forcesets. Sets settings.create_force_sets or settings.create_force_sets_zero to a list of files to read the forces from based on the `phonopy_disp.yaml` file.\n    \"\"\"\n    with open(\"phonopy_disp.yaml\", \"r\") as f:\n        data = yaml.safe_load(f)\n        num_disps = len(data[\"displacements\"])\n        if log_level &gt; 0:\n            print(f\"Found {num_disps} displacements.\")\n    # Change filenames\n    filenames = [\n        os.path.join(f\"disp-{i+1:03d}\", forces_filename) for i in range(num_disps)\n    ]\n\n    if settings.create_force_sets_zero:\n        filenames.insert(0, os.path.join(\"disp-000\", forces_filename))\n        settings.create_force_sets_zero = filenames\n    else:\n        settings.create_force_sets = filenames\n\n    if log_level &gt; 0:\n        print(\"Files to extract forces from:\")\n        print(filenames)\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._get_cell_info","title":"<code>_get_cell_info(cell_filename, calculator, magmoms=None)</code>","text":"<p>Get the cell info from a file.</p> <p>Parameters:</p> Name Type Description Default <code>cell_filename</code> <code>Path</code> <p>The path to the cell file.</p> required <code>calculator</code> <code>str</code> <p>The calculator to use.</p> required <code>magmoms</code> <code>ndarray</code> <p>The magnetic moments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The cell info dictionary.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def _get_cell_info(\n    cell_filename: Path, calculator: str, magmoms: Optional[np.ndarray] = None\n):\n    \"\"\"\n    Get the cell info from a file.\n\n    Args:\n        cell_filename (Path): The path to the cell file.\n        calculator (str): The calculator to use.\n        magmoms (np.ndarray): The magnetic moments.\n\n    Returns:\n        dict: The cell info dictionary.\n    \"\"\"\n    # Get cell info\n    cell_info = collect_cell_info(\n        interface_mode=calculator,\n        cell_filename=cell_filename,\n        supercell_matrix=np.diag(np.ones(3, dtype=int)),\n    )\n    if \"error_message\" in cell_info:\n        print(\"Phonopy returned this error while reading the cell:\")\n        print(cell_info[\"error_message\"])\n        raise PhonopyError(f\"Error reading the cell file {cell_filename}\")\n    # Set magnetic moments\n    if magmoms is not None:\n        unitcell = cell_info[\"unitcell\"]\n        try:\n            assert len(magmoms) in (len(unitcell), len(unitcell) * 3)\n            unitcell.magnetic_moments = magmoms\n        except AssertionError as e:\n            raise PhonopyError(\n                \"Number of magnetic moments does not match the number of atoms or \"\n                \"number of atoms times 3.\"\n            ) from e\n\n    return cell_info\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._find_standard_primitive","title":"<code>_find_standard_primitive(cell_info, symprec)</code>","text":"<p>Finds the standard primitive cell of a structure. This should find a cell similar to what you get from running <code>phonopy --symmetry</code></p> <p>Only supports non-magnetic systems. For magnetic systems it will just return the input cell as is.</p> <p>Parameters:</p> Name Type Description Default <code>cell_info</code> <code>dict</code> <p>The cell info dictionary.</p> required <code>symprec</code> <code>float</code> <p>The symmetry precision.</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def _find_standard_primitive(cell_info: dict, symprec: float) -&gt; Primitive:\n    \"\"\"\n    Finds the standard primitive cell of a structure. This should find a cell\n    similar to what you get from running `phonopy --symmetry`\n\n    Only supports non-magnetic systems. For magnetic systems it will just\n    return the input cell as is.\n\n    Args:\n        cell_info (dict): The cell info dictionary.\n        symprec (float): The symmetry precision.\n    \"\"\"\n    phonon = Phonopy(\n        cell_info[\"unitcell\"],\n        np.eye(3, dtype=int),\n        primitive_matrix=cell_info[\"primitive_matrix\"],\n        symprec=symprec,\n        calculator=cell_info[\"interface_mode\"],\n        log_level=0,\n    )\n\n    # Phonopy (and maybe spglib?) can't do this for magnetic systems\n    if phonon.unitcell.magnetic_moments is not None:\n        warnings.warn(\n            (\n                \"Warning: phonopy cannot handle finding standard primitive cell for \"\n                \"magnetic systems yet. I will pretend your input structure is \"\n                \"in primitive in the right setting and proceed with the calculation. \"\n                \"If not, this _may_ cause issues with quesadilla's nondiagonal \"\n                \"supercell calculations. Proceed with caution.\"\n            )\n        )\n        return phonon.primitive\n\n    (bravais_lattice, bravais_pos, bravais_numbers) = spglib.refine_cell(\n        phonon.primitive.totuple(), symprec\n    )\n    bravais_symbols = [atom_data[n][1] for n in bravais_numbers]\n    bravais = PhonopyAtoms(\n        symbols=bravais_symbols, scaled_positions=bravais_pos, cell=bravais_lattice\n    )\n    # Find the primitive cell\n    trans_mat = guess_primitive_matrix(bravais, symprec=symprec)\n    return get_primitive(bravais, trans_mat, symprec=symprec)\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.get_sc_gen","title":"<code>get_sc_gen(settings, cell_filename)</code>","text":"<p>Prepares a supercell generate object from the settings and cell filename.</p> <p>This function dumps a standard primitive cell from the cell file and proceeds to create a SupercellGenerator object from it, and generate the supercells necessary to span the q-grid.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def get_sc_gen(settings, cell_filename):\n    \"\"\"\n    Prepares a supercell generate object from the settings and cell filename.\n\n    This function dumps a standard primitive cell from the cell file and\n    proceeds to create a SupercellGenerator object from it, and generate the supercells\n    necessary to span the q-grid.\n    \"\"\"\n    primitive, cell_info = get_phonopy_prim(\n        cell_filename, calculator=settings.calculator\n    )\n    grid = np.diag(settings.supercell_matrix)\n    sc_gen = SupercellGenerator(primitive, grid)\n    # TODO: add arguments for minkowski and minimize\n    sc_gen.generate_supercells(minimize_supercells=True)\n    sc_gen.to_toml(\"quesadilla.toml\")\n    return cell_info, sc_gen\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.create_force_constants","title":"<code>create_force_constants(settings, confs, log_level)</code>","text":"<p>Create force constants from the force sets for each nondiagonal supercell.</p> <p>Reads the quesadilla.toml file to setup the SupercellGenerator, reads the force sets from each of the sc-i directories for each NDSC and computes the force constants for each NDSC, then uses a NondiagonalPhononCalculator to compute the final force constants for the full diagonal supercell.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>PhonopySettings</code> <p>Phonopy settings</p> required <code>log_level</code> <code>int</code> <p>Log level</p> required <code>confs</code> <code>dict</code> <p>Configuration settings</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def create_force_constants(settings: Phonopy, confs: dict, log_level: int):\n    \"\"\"\n    Create force constants from the force sets for each nondiagonal supercell.\n\n    Reads the quesadilla.toml file to setup the SupercellGenerator,\n    reads the force sets from each of the sc-i directories for each NDSC and\n    computes the force constants for each NDSC, then uses a NondiagonalPhononCalculator\n    to compute the final force constants for the full diagonal supercell.\n\n    Args:\n        settings (PhonopySettings): Phonopy settings\n        log_level (int): Log level\n        confs (dict): Configuration settings\n    \"\"\"\n    sc_gen = SupercellGenerator.from_toml(\"quesadilla.toml\")\n    nd_phonons = _get_nd_phonons(sc_gen, settings, log_level)\n    ndsc_calc = NondiagonalPhononCalculator(sc_gen, nd_phonons)\n    ndsc_calc.run()\n    units = get_default_physical_units(settings.calculator)\n    _write_final_phonopy_yaml(ndsc_calc.phonons, confs, units)\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli._get_nd_phonons","title":"<code>_get_nd_phonons(sc_gen, settings, log_level)</code>","text":"<p>Get a list of Phonopy objects for each nondiagonal supercell.</p> <p>Parameters:</p> Name Type Description Default <code>sc_gen</code> <p>SupercellGenerator object</p> required <code>settings</code> <p>PhonopySettings object</p> required <code>log_level</code> <p>int</p> required Source code in <code>quesadilla/cli.py</code> <pre><code>def _get_nd_phonons(sc_gen, settings, log_level):\n    \"\"\"\n    Get a list of Phonopy objects for each nondiagonal supercell.\n\n    Args:\n        sc_gen: SupercellGenerator object\n        settings: PhonopySettings object\n        log_level: int\n    \"\"\"\n\n    # All nondiagonal supercells have the same primitive cell\n    cell_filename = get_default_cell_filename(settings.calculator)\n    cell_info = _get_cell_info(\n        os.path.join(\"sc-001\", cell_filename), settings.calculator\n    )\n    nd_phonons = []\n    for i, sc_matrix in enumerate(sc_gen.sc_matrices):\n        if log_level &gt; 0:\n            print(f\"Reading force sets for supercell {i+1} in directory sc-{i+1:03d}\")\n        os.chdir(f\"sc-{i+1:03d}\")\n        # TODO: need to deal with magmoms here?\n        cell_info[\"supercell_matrix\"] = sc_matrix.T\n        # Initializes a phonopy object ready for force constant computation\n        phonon = _init_phonopy(\n            settings, cell_info, settings.symmetry_tolerance, log_level\n        )\n        # Read force sets and compute force constants in the phonon object\n        _produce_force_constants(phonon, settings, None, None, log_level)\n\n        nd_phonons.append(phonon)\n        if log_level &gt; 0:\n            print(\"------------------------------------\")\n        units = get_default_physical_units(settings.calculator)\n        _write_final_phonopy_yaml(phonon, {}, units)\n        os.chdir(\"..\")\n\n    return nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/cli/#quesadilla.cli.main","title":"<code>main()</code>","text":"<p>Main function of Quesadilla command line interface.</p> Source code in <code>quesadilla/cli.py</code> <pre><code>def main():\n    \"\"\"Main function of Quesadilla command line interface.\"\"\"\n    settings, confs, cell_filename, log_level = initialize_quesadilla()\n\n    if settings.create_displacements or settings.random_displacements:\n        cell_info, sc_gen = get_sc_gen(settings, cell_filename)\n        nd_phonons = create_displacements(sc_gen, settings, cell_info, log_level)\n        write_ndsc_with_displacement(\n            nd_phonons, settings.calculator, confs, cell_info[\"optional_structure_info\"]\n        )\n        sys.exit(0)\n\n    if settings.create_force_sets or settings.create_force_sets_zero:\n        forces_filename = (\n            settings.create_force_sets[0]\n            if settings.create_force_sets\n            else settings.create_force_sets_zero[0]\n        )\n        create_force_sets(settings, log_level, forces_filename)\n        sys.exit(0)\n\n    if settings.create_force_constants:\n        create_force_constants(settings, confs, log_level)\n        sys.exit(0)\n</code></pre>"},{"location":"reference/quesadilla/dynmat/","title":"dynmat","text":""},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator","title":"<code>NondiagonalPhononCalculator(sc_gen, nd_phonons)</code>","text":"Source code in <code>quesadilla/dynmat.py</code> <pre><code>def __init__(self, sc_gen: SupercellGenerator, nd_phonons: list[Phonopy]):\n    self.sc_gen = sc_gen\n    self.nd_phonons = nd_phonons\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator.from_toml","title":"<code>from_toml(toml_file)</code>  <code>classmethod</code>","text":"<p>Create a NondiagonalPhononCalculator object from a toml file.</p> <p>Generally the toml file is called quesadilla.toml and will be in the same directory as the sc-i directories, each of which should contain a phonopy.yaml file THAT MUST INCLUDE THE FORCE CONSTANTS computed from this supercell.</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>Path</code> <p>Path to the toml file</p> required <p>Returns:</p> Type Description <p>A NondiagonalPhononCalculator object</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>@classmethod\ndef from_toml(cls, toml_file: Path):\n    \"\"\"\n    Create a NondiagonalPhononCalculator object from a toml file.\n\n    Generally the toml file is called quesadilla.toml and will be\n    in the same directory as the sc-i directories, each of which\n    should contain a phonopy.yaml file THAT MUST INCLUDE THE\n    FORCE CONSTANTS computed from this supercell.\n\n    Args:\n        toml_file: Path to the toml file\n\n    Returns:\n        A NondiagonalPhononCalculator object\n    \"\"\"\n    # TODO: move to CLI (maybe?)\n    sc_gen = SupercellGenerator.from_toml(toml_file)\n    root = os.path.dirname(toml_file)\n    nd_phonons = cls._parse_ndsc_phonons(root, sc_gen)\n\n    return cls(sc_gen, nd_phonons)\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._parse_ndsc_phonons","title":"<code>_parse_ndsc_phonons(root, sc_gen)</code>  <code>staticmethod</code>","text":"<p>Reads the phonopy.yaml files from the supercells generated by Quesadilla</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>Path to the directory containing the supercells</p> required <code>sc_gen</code> <code>SupercellGenerator</code> <p>SupercellGenerator object</p> required Source code in <code>quesadilla/dynmat.py</code> <pre><code>@staticmethod\ndef _parse_ndsc_phonons(root: Path, sc_gen: SupercellGenerator) -&gt; list[Phonopy]:\n    \"\"\"\n    Reads the phonopy.yaml files from the supercells generated by Quesadilla\n\n    Args:\n        root: Path to the directory containing the supercells\n        sc_gen: SupercellGenerator object\n    \"\"\"\n    # TODO: move to CLI (maybe?)\n    n_sc = len(\n        [d for d in os.listdir(root) if d.startswith(\"sc-\") and d[3:].isdigit()]\n    )\n    assert n_sc == len(sc_gen.sc_matrices), \"Number of supercells does not match\"\n    phonons = [\n        phonopy.load(\n            os.path.join(root, f\"sc-{i+1:03d}\", \"phonopy.yaml\"),\n            is_symmetry=False,\n            symmetrize_fc=False,\n        )\n        for i in range(n_sc)\n    ]\n    # Now assert that the supercell matrices are the same\n    for i, (p, T) in enumerate(zip(phonons, sc_gen.sc_matrices)):\n        assert np.all(\n            p.supercell_matrix.T == T\n        ), f\"{i+1}: Supercell matrices do not match, {p.supercell_matrix.T} vs {T}\"\n\n    return phonons\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._get_dynmat_in_ibz","title":"<code>_get_dynmat_in_ibz(average_gamma=False, average_non_gamma=False)</code>","text":"<p>Gets the Fourier transformed force constant matrices</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>def _get_dynmat_in_ibz(\n    self,\n    average_gamma: bool = False,\n    average_non_gamma: bool = False,\n) -&gt; dict[tuple[float, float, float], np.ndarray]:\n    \"\"\"\n    Gets the Fourier transformed force constant matrices\n    \"\"\"\n    dynmats = {}\n    for i, p in enumerate(self.nd_phonons):\n        for q in self.sc_gen.q_comm[i]:\n            T = p.supercell_matrix\n            assert np.allclose(\n                T.T @ q, (T.T @ q).astype(int)\n            ), \"q is not commensurate?\"\n            p.dynamical_matrix.run(q)\n            dynmats.setdefault(tuple(q), []).append(\n                p.dynamical_matrix.dynamical_matrix\n            )\n\n    for q, dyn_mats in dynmats.items():\n        print(f\"Found {len(dyn_mats)} dynamical matrices at q = {np.round(q, 5)}\")\n        if q == (0, 0, 0):\n            dynmats[q] = np.mean(dyn_mats, axis=0) if average_gamma else dyn_mats[0]\n        elif len(dyn_mats) &gt; 1:\n            dynmats[q] = (\n                np.mean(dyn_mats, axis=0) if average_non_gamma else dyn_mats[0]\n            )\n        else:\n            dynmats[q] = dyn_mats[0]\n\n    return dynmats\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._get_phonopy_from_fcq","title":"<code>_get_phonopy_from_fcq(full_fcq)</code>","text":"<p>Create a Phonopy object from the full force constant matrix.</p> <p>Parameters:</p> Name Type Description Default <code>sc_gen</code> <p>SupercellGenerator object</p> required <code>full_fcq</code> <code>dict[tuple[float, float, float], ndarray]</code> <p>The full force constant matrix</p> required Source code in <code>quesadilla/dynmat.py</code> <pre><code>def _get_phonopy_from_fcq(\n    self, full_fcq: dict[tuple[float, float, float], np.ndarray]\n) -&gt; Phonopy:\n    \"\"\"\n    Create a Phonopy object from the full force constant matrix.\n\n    Args:\n        sc_gen: SupercellGenerator object\n        full_fcq: The full force constant matrix\n    \"\"\"\n    print(\"Creating the Phonopy object...\")\n    nd_phonon = Phonopy(\n        self.sc_gen.primitive, supercell_matrix=np.diag(self.sc_gen.grid)\n    )\n    print(\"Fourier transforming the force constants back to real space...\")\n    nd_phonon.force_constants = self._fcq_to_fcr(\n        full_fcq,\n    )\n    print(\"Applying acoustic sum rules...\")\n    nd_phonon.symmetrize_force_constants()\n    return nd_phonon\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._fcq_to_fcr","title":"<code>_fcq_to_fcr(fcq)</code>","text":"<p>Fourier transform the force constants on the full q-grid to real space.</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>def _fcq_to_fcr(\n    self, fcq: dict[tuple[float, float, float], np.ndarray]\n) -&gt; np.ndarray:\n    \"\"\"\n    Fourier transform the force constants on the full q-grid to real\n    space.\n    \"\"\"\n    all_q = np.array(list(fcq.keys()))\n    print(f\"Found {len(all_q)} q-points in the full BZ\")\n    dynmat = np.array([self._fcq_to_dynmat(fcq[tuple(q)], q) for q in all_q])\n    d2f = DynmatToForceConstants(\n        self.sc_gen.primitive,\n        self.sc_gen.supercell,\n        is_full_fc=True,\n    )\n    d2f.commensurate_points = all_q\n    d2f.dynamical_matrices = dynmat\n    print(\"Running DynmatToForceConstants...\")\n    d2f.run()\n    return d2f.force_constants\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._dynmat_to_fcq","title":"<code>_dynmat_to_fcq(D, q)</code>","text":"<p>Converts the dynamical matrix as defined by phonopy into the Fourier transformer force constant matrix as defined by Quantum ESPRESSO and read by Quesadilla's symmetry routines.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <p>The primitive structure</p> required <code>D</code> <code>ndarray</code> <p>The dynamical matrix (3nat x 3nat)</p> required <code>q</code> <code>ArrayLike</code> <p>The q-point in FRAC coords</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The Fourier transformed force constant matrix (3nat x 3nat)</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>def _dynmat_to_fcq(self, D: np.ndarray, q: ArrayLike) -&gt; np.ndarray:\n    \"\"\"\n    Converts the dynamical matrix as defined by phonopy into\n    the Fourier transformer force constant matrix as defined\n    by Quantum ESPRESSO and read by Quesadilla's symmetry routines.\n\n    Args:\n        prim: The primitive structure\n        D: The dynamical matrix (3*nat x 3*nat)\n        q: The q-point in FRAC coords\n\n    Returns:\n        The Fourier transformed force constant matrix (3*nat x 3*nat)\n    \"\"\"\n    N = len(self.sc_gen.primitive)\n    D_blocks = D.reshape(N, 3, N, 3).swapaxes(1, 2)\n    masses = self.sc_gen.primitive.masses\n    for i, j in itertools.product(range(N), range(N)):\n        # Get fractional coordinates\n        r_i = self.sc_gen.primitive.scaled_positions[i]\n        r_j = self.sc_gen.primitive.scaled_positions[j]\n        D_blocks[i, j] *= (\n            np.exp(1j * 2 * np.pi * np.dot(q, r_i))\n            * np.exp(-1j * 2 * np.pi * np.dot(q, r_j))\n            * np.sqrt(masses[i] * masses[j])\n        )\n    return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)\n</code></pre>"},{"location":"reference/quesadilla/dynmat/#quesadilla.dynmat.NondiagonalPhononCalculator._fcq_to_dynmat","title":"<code>_fcq_to_dynmat(fcq, q)</code>","text":"<p>Converts the Fourier transformed force constant matrix as defined by Quantum ESPRESSO and produced by Quesadilla's symmetry routines into the dynamical matrix as defined by phonopy.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <p>The primitive structure</p> required <code>fcq</code> <code>ndarray</code> <p>The Fourier transformed force constant matrix (3nat x 3nat)</p> required <code>q</code> <code>ndarray</code> <p>The q-point in FRAC coords</p> required <p>Returns:</p> Type Description <p>The dynamical matrix (3nat x 3nat)</p> Source code in <code>quesadilla/dynmat.py</code> <pre><code>def _fcq_to_dynmat(self, fcq: np.ndarray, q: np.ndarray):\n    \"\"\"\n    Converts the Fourier transformed force constant matrix as defined\n    by Quantum ESPRESSO and produced by Quesadilla's symmetry routines into\n    the dynamical matrix as defined by phonopy.\n\n    Args:\n        prim: The primitive structure\n        fcq: The Fourier transformed force constant matrix (3*nat x 3*nat)\n        q: The q-point in FRAC coords\n\n    Returns:\n        The dynamical matrix (3*nat x 3*nat)\n    \"\"\"\n    N = len(self.sc_gen.primitive)\n    masses = self.sc_gen.primitive.masses\n    D_blocks = fcq.reshape(N, 3, N, 3).swapaxes(1, 2)\n    for i, j in itertools.product(range(N), range(N)):\n        # Get fractional coordinates\n        r_i = self.sc_gen.primitive.scaled_positions[i]\n        r_j = self.sc_gen.primitive.scaled_positions[j]\n        D_blocks[i, j] *= (\n            np.exp(-1j * 2 * np.pi * np.dot(q, r_i))\n            * np.exp(1j * 2 * np.pi * np.dot(q, r_j))\n            / np.sqrt(masses[i] * masses[j])\n        )\n    return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)\n</code></pre>"},{"location":"reference/quesadilla/supercells/","title":"supercells","text":""},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator","title":"<code>SupercellGenerator(atoms, grid, q_ibz=None, sc_matrices=None, sc_sizes=None, q_comm=None)</code>","text":"Source code in <code>quesadilla/supercells.py</code> <pre><code>def __init__(\n    self,\n    atoms: PhonopyAtoms,\n    grid: ArrayLike,\n    q_ibz: np.ndarray = None,\n    sc_matrices: np.ndarray = None,\n    sc_sizes: np.ndarray = None,\n    q_comm: list = None,\n):\n    # Setup primitive structure and supercell\n    grid = np.array(grid)\n    self.supercell = Supercell(atoms, np.diag(grid))\n    self.primitive = Primitive(self.supercell, np.diag(1 / grid))\n    # Setup BZ data\n    self.grid = grid\n    if q_ibz is None:\n        self.q_ibz = self.get_ibz()\n    else:\n        q_ibz = np.array(q_ibz)\n        q_ibz = q_ibz[np.lexsort(q_ibz.T)]\n        try:\n            assert np.allclose(q_ibz, self.get_ibz())\n        except AssertionError as e:\n            raise ValueError(\n                \"IBZ q-points passed do not match what we expect from the \"\n                \"structure's symmetry.\"\n            ) from e\n\n    # Setup supercell data\n    self.sc_matrices = np.array(sc_matrices) if sc_matrices is not None else None\n    self.sc_sizes = np.array(sc_sizes) if sc_sizes is not None else None\n    self.q_comm = q_comm\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.get_ibz","title":"<code>get_ibz()</code>","text":"<p>Gets the q points in a structures IBZ. The output is sorted for consistency.</p> <ul> <li>primitive: phonopy.structure.cells.Primitive     The input structure (primitive cell, assumed to be standardized).</li> <li>grid: array-like     The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).</li> </ul> <ul> <li>qpoints: numpy.ndarray     The q points in the IBZ (fractional coordinates, sorted).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def get_ibz(\n    self,\n) -&gt; np.ndarray:\n    \"\"\"\n    Gets the q points in a structures IBZ. The output is sorted for consistency.\n\n    Parameters:\n    - primitive: phonopy.structure.cells.Primitive\n        The input structure (primitive cell, assumed to be standardized).\n    - grid: array-like\n        The grid of q points (e.g., [4, 4, 4] for a 4x4x4 grid).\n\n    Returns:\n    - qpoints: numpy.ndarray\n        The q points in the IBZ (fractional coordinates, sorted).\n    \"\"\"\n    grid = np.array(self.grid)\n    # Contruct the SPG-style cell tuple\n    # https://spglib.readthedocs.io/en/stable/python-interface.html#crystal-structure-cell\n    mapping = {\n        element: i + 1 for i, element in enumerate(set(self.primitive.symbols))\n    }\n    zs = [mapping[element] for element in self.primitive.symbols]\n    cell = (\n        tuple(map(tuple, self.primitive.cell.tolist())),\n        tuple(map(tuple, self.primitive.scaled_positions.tolist())),\n        tuple(zs),\n    )\n    # Get irr q-points\n    # TODO: cell = primitive.totuple()\n    mapping, all_qpoints = spglib.get_ir_reciprocal_mesh(\n        grid, cell, is_shift=np.zeros(3), symprec=1e-5\n    )\n    irr_qpoints = np.array([all_qpoints[idx] / grid for idx in np.unique(mapping)])\n\n    # Sort by (z, y, x) for consistency\n    return irr_qpoints[np.lexsort(irr_qpoints.T)]\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._atoms_to_toml","title":"<code>_atoms_to_toml()</code>","text":"<p>Convert the primitive structure to a TOML table.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def _atoms_to_toml(self) -&gt; tomlkit.table:\n    \"\"\"\n    Convert the primitive structure to a TOML table.\n    \"\"\"\n    if self.primitive is None:\n        raise ValueError(\"Primitive structure must be set.\")\n\n    primitive_toml = tomlkit.table()\n    primitive_toml.add(\"lattice\", np.round(self.primitive.cell, 12).tolist())\n    primitive_toml.add(\"species\", self.primitive.symbols)\n    primitive_toml.add(\n        \"frac_coords\", np.round(self.primitive.scaled_positions, 12).tolist()\n    )\n    primitive_toml[\"lattice\"].multiline(True)\n    primitive_toml[\"frac_coords\"].multiline(True)\n    return primitive_toml\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._bz_to_toml","title":"<code>_bz_to_toml()</code>","text":"<p>Convert the Brillouin zone data to a TOML table.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def _bz_to_toml(self) -&gt; tomlkit.table:\n    \"\"\"\n    Convert the Brillouin zone data to a TOML table.\n    \"\"\"\n    if self.grid is None or self.q_ibz is None:\n        raise ValueError(\"Grid and irreducible q-points must be set.\")\n    bz_toml = tomlkit.table()\n    bz_toml.add(\"grid\", self.grid.tolist())\n    bz_toml.add(\"irreducible_q\", self.q_ibz.tolist())\n    bz_toml[\"irreducible_q\"].multiline(True)\n    return bz_toml\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._supercells_to_toml","title":"<code>_supercells_to_toml()</code>","text":"<p>Convert the supercells data to a TOML array of tables.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def _supercells_to_toml(self) -&gt; tomlkit.aot:\n    \"\"\"\n    Convert the supercells data to a TOML array of tables.\n    \"\"\"\n    if self.sc_matrices is None or self.sc_sizes is None or self.q_comm is None:\n        raise ValueError(\"Supercell data must be set.\")\n\n    supercells_toml = tomlkit.aot()\n    for i, (T, sz, q) in enumerate(\n        zip(self.sc_matrices, self.sc_sizes, self.q_comm)\n    ):\n        sc_table = tomlkit.table()\n        sc_table.add(\"index\", i + 1)\n        sc_table.add(\"size\", int(sz))\n        sc_table.add(\"commensurate_q\", q.tolist())\n        sc_table[\"commensurate_q\"].multiline(True)\n        sc_table.add(\"matrix\", T.tolist())\n        sc_table[\"matrix\"].multiline(True)\n        supercells_toml.append(sc_table)\n    return supercells_toml\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.to_toml","title":"<code>to_toml(output_file)</code>","text":"<p>Write the supercell data to a TOML file.</p> <ul> <li>output_file: str     The output file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def to_toml(self, output_file):\n    \"\"\"\n    Write the supercell data to a TOML file.\n\n    Parameters:\n    - output_file: str\n        The output file path.\n    \"\"\"\n    doc = tomlkit.document()\n    doc.add(\"primitive\", self._atoms_to_toml())\n    doc.add(\"brillouin_zone\", self._bz_to_toml())\n    doc.add(\"supercells\", self._supercells_to_toml())\n\n    with open(output_file, \"w\") as f:\n        f.write(doc.as_string())\n    print(f\"Supercells written to {output_file}\")\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.from_toml","title":"<code>from_toml(input_file)</code>  <code>classmethod</code>","text":"<p>Read the supercell data from a TOML file.</p> <ul> <li>input_file: str     The input file path.</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>@classmethod\ndef from_toml(cls, input_file: str):\n    \"\"\"\n    Read the supercell data from a TOML file.\n\n    Parameters:\n    - input_file: str\n        The input file path.\n    \"\"\"\n\n    with open(input_file, \"rb\") as f:\n        data = tomli.load(f)\n\n    primitive = cls.atoms_from_toml(data[\"primitive\"])\n    bz = data[\"brillouin_zone\"]\n    grid = bz[\"grid\"]\n    irr_q = np.array(bz[\"irreducible_q\"])\n\n    if \"supercells\" in data:\n        supercells = data[\"supercells\"]\n        T_matrices = np.array([sc[\"matrix\"] for sc in supercells])\n        sc_size = np.array([sc[\"size\"] for sc in supercells])\n        comm_q = [np.array(sc[\"commensurate_q\"]) for sc in supercells]\n    else:\n        T_matrices = None\n        sc_size = None\n        comm_q = None\n    return cls(primitive, grid, irr_q, T_matrices, sc_size, comm_q)\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.atoms_from_toml","title":"<code>atoms_from_toml(data)</code>  <code>staticmethod</code>","text":"<p>Reconstructs a PhonopyAtoms object from TOML data.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>@staticmethod\ndef atoms_from_toml(data: dict) -&gt; PhonopyAtoms:\n    \"\"\"Reconstructs a PhonopyAtoms object from TOML data.\"\"\"\n    return PhonopyAtoms(\n        symbols=data[\"species\"],\n        scaled_positions=np.array(data[\"frac_coords\"]),\n        cell=np.array(data[\"lattice\"]),\n    )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator.generate_supercells","title":"<code>generate_supercells(minkowski_reduce=True, minimize_supercells=False)</code>","text":"<p>Generate nondiagonal supercells commensurate with the IBZ.</p> <ul> <li>reduce: bool     Whether to Minkowski reduce the supercells (default: True, recommended).</li> <li>trim: bool     Whether to trim the supercells using ILP (default: False, broken).</li> </ul> Source code in <code>quesadilla/supercells.py</code> <pre><code>def generate_supercells(\n    self, minkowski_reduce: bool = True, minimize_supercells: bool = False\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate nondiagonal supercells commensurate with the IBZ.\n\n    Parameters:\n    - reduce: bool\n        Whether to Minkowski reduce the supercells (default: True, recommended).\n    - trim: bool\n        Whether to trim the supercells using ILP (default: False, broken).\n    \"\"\"\n\n    self.sc_matrices = self._get_ndsc_matrices()\n    if minkowski_reduce:\n        self.sc_matrices = np.array(\n            [minkowski_reduce_sc(T, self.primitive.cell) for T in self.sc_matrices]\n        )\n\n    self.sc_sizes = np.array([np.linalg.det(T) for T in self.sc_matrices])\n    self.q_comm = [\n        np.array([q for q in self.q_ibz if np.allclose(np.rint(T @ q), T @ q)])\n        for T in self.sc_matrices\n    ]\n\n    if minimize_supercells:\n        print(\n            f\"We have {len(self.sc_matrices)} q-points in IBZ necessitating \"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{int(np.sum(self.sc_sizes)):3d}\"\n        )\n        self._pick_smallest_supercells()\n        print(\n            f\"After minimization, we only need \"\n            f\"{len(self.sc_matrices)} supercells with total size \"\n            f\"{int(np.sum(self.sc_sizes)):3d}\"\n        )\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._get_ndsc_matrices","title":"<code>_get_ndsc_matrices()</code>","text":"<p>Generate nondiagonal supercell matrices commensurate with the IBZ.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def _get_ndsc_matrices(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate nondiagonal supercell matrices commensurate with the IBZ.\n    \"\"\"\n    qpoints_frac = convert_to_fraction_array(self.q_ibz)\n    sc_matrices = np.zeros((self.q_ibz.shape[0], 3, 3), dtype=int)\n\n    for i, Q in enumerate(qpoints_frac):\n        sc_matrices[i, :] = find_nondiagonal(Q)\n\n    return sc_matrices\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._pick_smallest_supercells","title":"<code>_pick_smallest_supercells()</code>","text":"<p>Solves the set cover problem with associated supercell sizes, selecting the smallest set of supercells that cover all q points in the IBZ while minimizing the total size of the selected supercells.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.SupercellGenerator._pick_smallest_supercells--notes","title":"Notes:","text":"<p>This function uses integer linear programming (ILP) to ensure an optimal selection of supercells with the smallest total size while covering all q-points. The function requires the <code>pulp</code> library to solve the ILP problem.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def _pick_smallest_supercells(self) -&gt; np.ndarray[bool]:\n    \"\"\"\n    Solves the set cover problem with associated supercell sizes, selecting the\n    smallest set of supercells that cover all q points in the IBZ while minimizing\n    the total size of the selected supercells.\n\n    Notes:\n    ------\n    This function uses integer linear programming (ILP) to ensure an optimal\n    selection of supercells with the smallest total size while covering all\n    q-points. The function requires the `pulp` library to solve the ILP problem.\n    \"\"\"\n    nq = len(self.sc_sizes)\n    # commensurate[i, j] is True if supercell `i` is commensurate with q-point `j`.\n    commensurate = np.full((nq, nq), False, dtype=bool)\n    for i, T in enumerate(self.sc_matrices):\n        commensurate[i, :] = [np.all(T @ q == np.round(T @ q)) for q in self.q_ibz]\n\n    # Create a problem instance\n    prob = pulp.LpProblem(\"PickSmallestSupercells\", pulp.LpMinimize)\n\n    # Create binary variables for each supercell\n    x = [pulp.LpVariable(f\"x_{i}\", cat=\"Binary\") for i in range(nq)]\n\n    # Objective function: Minimize the total supercell size\n    prob += pulp.lpSum(self.sc_sizes[i] * x[i] for i in range(nq))\n\n    # Constraints: Ensure each q-point is covered by at least one bin\n    for j in range(nq):\n        prob += pulp.lpSum(commensurate[i, j] * x[i] for i in range(nq)) &gt;= 1\n\n    # Solve the problem\n    prob.solve(pulp.PULP_CBC_CMD(msg=False))\n\n    # Get the selected supercells and total size\n    selected_cells = [int(pulp.value(x[i])) for i in range(nq)]\n    selected_cells = [i for i in range(nq) if selected_cells[i] == 1]\n\n    self.sc_matrices = self.sc_matrices[selected_cells]\n    self.sc_sizes = self.sc_sizes[selected_cells]\n    self.q_comm = [self.q_comm[i] for i in selected_cells]\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.convert_to_fraction_array","title":"<code>convert_to_fraction_array(arr)</code>","text":"<p>Takes a numpy array of floats and converts them to fractions.</p> <p>The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def convert_to_fraction_array(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Takes a numpy array of floats and converts them to fractions.\n\n    The output array has shape (N, 2, M) where N is the number of rows in the input array and M is the number of columns. The second dimension is used to store the numerator and denominator of the fraction, respectively.\n    \"\"\"\n    result = np.empty((arr.shape[0], 2, arr.shape[1]), dtype=int)\n\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            frac = Fraction(arr[i, j]).limit_denominator()\n            result[i, 0, j] = frac.numerator\n            result[i, 1, j] = frac.denominator\n\n    return result\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_integers","title":"<code>find_integers(nums, g23, g12, g31, g123)</code>","text":"<p>Compute integers for off-diagonal supercell matrix elements Called by find_nondiagonal()</p> <p>This function is copied from QEPlayground</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_integers(nums, g23, g12, g31, g123):\n    \"\"\"\n    Compute integers for off-diagonal supercell matrix elements\n    Called by find_nondiagonal()\n\n    This function is copied from QEPlayground\n    \"\"\"\n    # Compute p (it's a modulo equation)\n    if g23 == 1:\n        p = 0\n    else:\n        for i in range(1, g23):\n            if (nums[1] + i * nums[2]) % g23 == 0:\n                p = i\n                break\n        # Compute q\n    g12_r = int(g12 / g123)\n    g23_r = int(g23 / g123)\n    g31_r = int(g31 / g123)\n    if g12_r == 1:\n        q = 0\n    else:\n        for i in range(1, g12_r):\n            if (g23_r * nums[0] + i * g31_r * nums[1]) % g12_r == 0:\n                q = i\n                break\n    # Compute r\n    gg_r = int(g31 * g23 / g123)\n    z = g23 * nums[0] / g12 + g31 * q * nums[1] / g12\n    if gg_r == 1:\n        r = 0\n    else:\n        for i in range(1, gg_r):\n            if (z + i * nums[2]) % gg_r == 0:\n                r = i\n                break\n    return p, q, r\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.find_nondiagonal","title":"<code>find_nondiagonal(Q)</code>","text":"<p>Nondiagonal supercell, based on [Phys. Rev. B 92, 184301] This function is copied from QEPlayground</p> <p>Parameters:</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def find_nondiagonal(Q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Nondiagonal supercell, based on [Phys. Rev. B 92, 184301]\n    This function is copied from QEPlayground\n\n    Parameters:\n    \"\"\"\n    # Take care of components already at Gamma\n    Q[1, np.where(Q[0] == 0)] = 1\n    # Shift the q-point into the positive quadrant of the reciprocal unit cell\n    Q[0, np.where(Q[0] &lt; 0)] += Q[1, np.where(Q[0] &lt; 0)]\n    # GCDs of Q[1] (in the logical order of the derivation)\n    g23 = math.gcd(Q[1, 1], Q[1, 2])\n    g12 = math.gcd(Q[1, 0], Q[1, 1])\n    g31 = math.gcd(Q[1, 2], Q[1, 0])\n    g123 = math.gcd(Q[1, 0], math.gcd(Q[1, 1], Q[1, 2]))\n    # Integers needed to solve the supercell matrix equation\n    p, q, r = find_integers(Q[0], g23, g12, g31, g123)\n    # Matrix elements (in order of derivation) and supercell matrix\n    S_33 = Q[1, 2]\n    S_22 = Q[1, 1] / g23\n    S_23 = p * Q[1, 2] / g23\n    S_11 = g123 * Q[1, 0] / (g12 * g31)\n    S_12 = q * g123 * Q[1, 1] / (g12 * g23)\n    S_13 = r * g123 * Q[1, 2] / (g31 * g23)\n    return np.array([[S_11, S_12, S_13], [0, S_22, S_23], [0, 0, S_33]])\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.minkowski_reduce_sc","title":"<code>minkowski_reduce_sc(T, lattice)</code>","text":"<p>Reduce a supercell matrix using Minkowski reduction.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>ndarray</code> <p>Supercell matrix.</p> required <code>lattice</code> <code>ndarray</code> <p>Primitive lattice.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def minkowski_reduce_sc(T, lattice):\n    \"\"\"\n    Reduce a supercell matrix using Minkowski reduction.\n\n    Args:\n        T (numpy.ndarray): Supercell matrix.\n        lattice (numpy.ndarray): Primitive lattice.\n\n    Returns:\n        numpy.ndarray: Minkowski-reduced supercell matrix with positive determinant.\n    \"\"\"\n    ndsc_lattice = np.dot(T, lattice)\n    ndsc_lattice = mink_reduce(ndsc_lattice)\n    T = np.dot(\n        ndsc_lattice,\n        np.linalg.inv(lattice),\n    )\n    return make_positive_det(np.rint(T).astype(int))\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.make_positive_det","title":"<code>make_positive_det(matrix)</code>","text":"<p>If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Input square matrix.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Adjusted matrix.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def make_positive_det(matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    If the matrix has a negative determinant, this function flips the sign of the row with the most negative entries. Phonopy requires the supercell matrix to have a positive determinant. This doesn't change the q-point that the supercell is commensurate with.\n\n    Args:\n        matrix (numpy.ndarray): Input square matrix.\n\n    Returns:\n        numpy.ndarray: Adjusted matrix.\n    \"\"\"\n    if np.linalg.det(matrix) &lt; 0:\n        # Find the row index with the most negative entries\n        negative_sums = np.sum(np.minimum(matrix, 0), axis=1)\n        row_to_flip = np.argmin(negative_sums)\n        matrix[row_to_flip] *= -1\n\n    return matrix\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce","title":"<code>mink_reduce(vecs, tol=1e-07, max_iter=100)</code>","text":"<p>Perform Minkowski reduction on a set of 3 vectors in 3D space.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row represents a 3D vector. tol : float, optional     Tolerance for floating-point comparisons, default is 1e-7. max_iter : int, optional     Maximum number of iterations, default is 100.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.mink_reduce--returns","title":"Returns","text":"<p>np.ndarray     Minkowski-reduced vectors.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def mink_reduce(vecs: np.ndarray, tol: float = 1e-7, max_iter: int = 100) -&gt; np.ndarray:\n    \"\"\"\n    Perform Minkowski reduction on a set of 3 vectors in 3D space.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row represents a 3D vector.\n    tol : float, optional\n        Tolerance for floating-point comparisons, default is 1e-7.\n    max_iter : int, optional\n        Maximum number of iterations, default is 100.\n\n    Returns\n    -------\n    np.ndarray\n        Minkowski-reduced vectors.\n    \"\"\"\n    if vecs.shape != (3, 3):\n        raise ValueError(\"Input must have shape (3, 3).\")\n\n    i = 0\n    while True:\n        # Keep track of whether any reduction occurred\n        changed = False\n\n        for i in range(3):\n            temp_vecs = vecs.copy()\n            temp_vecs[i] = 0.0  # Temporarily zero out the i-th vector\n            reduced_vecs = reduce_vectors(temp_vecs, tol)\n            reduced_vecs[i] = vecs[i]  # Restore the i-th vector\n\n            if not np.allclose(reduced_vecs, vecs):\n                vecs = reduced_vecs\n                changed = True\n                break\n\n        # Check combinations involving all three vectors\n        if not changed:\n            reduced_vecs = reduce_vectors(vecs, tol)\n            if not np.allclose(reduced_vecs, vecs, atol=tol, rtol=0):\n                vecs = reduced_vecs\n                continue\n\n        # Stop if no changes occurred in this iteration\n        if not changed:\n            break\n\n        i += 1\n        if i &gt; max_iter:\n            raise RuntimeError(\"Too many iterations in Minkowski reduction.\")\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors","title":"<code>reduce_vectors(vecs, tol)</code>","text":"<p>Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--parameters","title":"Parameters","text":"<p>vecs : np.ndarray of shape (3, 3)     Input array where each row is a 3D vector. tol : float     Tolerance for floating-point comparisons.</p>"},{"location":"reference/quesadilla/supercells/#quesadilla.supercells.reduce_vectors--returns","title":"Returns","text":"<p>np.ndarray     A new array with the reduced vectors if a reduction occurs, or the original array unchanged.</p> Source code in <code>quesadilla/supercells.py</code> <pre><code>def reduce_vectors(vecs: np.ndarray, tol: float) -&gt; np.ndarray:\n    \"\"\"\n    Reduce three 3D vectors by replacing the longest vector with a linear combination that is shorter.\n\n    Parameters\n    ----------\n    vecs : np.ndarray of shape (3, 3)\n        Input array where each row is a 3D vector.\n    tol : float\n        Tolerance for floating-point comparisons.\n\n    Returns\n    -------\n    np.ndarray\n        A new array with the reduced vectors if a reduction occurs, or the original array unchanged.\n    \"\"\"\n    lengths_sq = np.sum(vecs**2, axis=1)\n    longest_idx = np.argmax(lengths_sq)\n    max_len_sq = lengths_sq[longest_idx]\n\n    a, b, c = vecs\n    candidates = [\n        a + b - c,\n        a - b + c,\n        -a + b + c,\n        a + b + c,\n    ]\n\n    for candidate in candidates:\n        if np.dot(candidate, candidate) &lt; max_len_sq * (1 - tol):\n            new_vecs = vecs.copy()\n            new_vecs[longest_idx] = candidate\n            return new_vecs\n\n    return vecs\n</code></pre>"},{"location":"reference/quesadilla/symmetries/","title":"symmetries","text":""},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer","title":"<code>Symmetrizer(primitive, threshold=1e-05)</code>","text":"<p>The constructor takes the pymatgen Structure object and sets up attributes in a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.</p> <p>Parameters:</p> Name Type Description Default <code>primitive</code> <code>Primitive</code> <p>The primitive cell of the structure</p> required <code>Threshold</code> <p>Numerical threshold for symmetry detection, defaults to 1e-5.</p> required Source code in <code>quesadilla/symmetries.py</code> <pre><code>def __init__(\n    self,\n    primitive: Primitive,\n    threshold: float = 1e-5,\n):\n    \"\"\"Initialize a symmetry analysis object for a structure.\n\n    The constructor takes the pymatgen Structure object and sets up attributes in\n    a FORTRAN friendly manner. Its various methods call the Quantum ESPRESSO\n    symmetry routines to compute the Fourier-transformed force constants in the star of a given q-point, and then symmetrize them using space group symmetries.\n\n    Args:\n        primitive: The primitive cell of the structure\n        Threshold: Numerical threshold for symmetry detection, defaults to 1e-5.\n    \"\"\"\n\n    # Define QE Variables with fortran-ready data types\n    # NOTE: we use the same names as the QE Fortran routines\n    # self.nat = np.intc(len(structure))  # Number of atoms\n    self.nat = np.intc(len(primitive))  # Number of atoms\n    # assert self.nat == self.nat2, \"Number of atoms do not match\"\n    # s(:,:,i) is the i-th symmetry operation. Zeros for missing symmetries\n    self.s = np.zeros((3, 3, 48), dtype=np.intc, order=\"F\")\n    # irt(i,j) is the index of the atom you get from applying symmetry i to atom j\n    self.irt = np.zeros((48, self.nat), dtype=np.intc, order=\"F\")\n    # Array with index of inverse symmetry of each operation\n    self.invs = np.zeros((48), dtype=np.intc, order=\"F\")\n    # Array with S.r_a - r_a for each symm op and atom a\n    self.rtau = np.zeros((3, 48, self.nat), dtype=np.float64, order=\"F\")\n    # ft(:, j) is the fractional translation of symmetry j in FRAC coords\n    self.ft = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the crystal\n    self.nsym = np.intc(0)\n    # Number of symmetries in the Bravais lattice\n    self.nrot = np.intc(0)\n\n    # Whether there is a symm op S_{-} such that S_{-} . q = -q + G\n    self.minus_q = np.array([True], dtype=np.intc)\n    # s(:, :, irotmq) is the symmetry operation that maps q to -q + G\n    self.irotmq = np.intc(0)\n    # This is the G vector in S_{-} . q = -q + G\n    self.gimq = np.zeros((3), dtype=np.float64, order=\"F\")\n    # gi(:, i) is the G vector in S(:,:,i)@q = q + G\n    self.gi = np.zeros((3, 48), dtype=np.float64, order=\"F\")\n    # Number of symmetries in the star of a q-point\n    self.nsymq = np.intc(0)\n\n    # Assign unique number to each species\n    mapping = {element: i + 1 for i, element in enumerate(set(primitive.symbols))}\n    self.ityp = np.array(\n        [mapping[element] for element in primitive.symbols], dtype=np.intc\n    )\n    # Atoms' cartesian coordinates\n    self.tau = primitive.positions.T\n    # # Lattice vectors (QE routines expect columns as basis vectors)\n    self.at = np.array(primitive.cell.T, dtype=np.float64, order=\"F\")\n    # Reciprocal lattice vectors/(2pi) (QE routines expect columns as basis vectors)\n    recip_lattice = np.linalg.inv(primitive.cell).T * (2 * np.pi)\n    self.bg = np.array(recip_lattice.T / (2 * np.pi), dtype=np.float64, order=\"F\")\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_xq_from_aq","title":"<code>get_xq_from_aq(aq)</code>","text":"<p>Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>aq</code> <p>ndarray(3) The q-point in fractional coordinates.</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_xq_from_aq(self, aq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in Cartesian coordinates / (2*pi) from a q-point in fractional coordinates.\n\n    Parameters:\n        - aq : ndarray(3)\n            The q-point in fractional coordinates.\n\n    Returns:\n        ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n    \"\"\"\n    return np.dot(aq, self.bg.T)\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_aq_from_xq","title":"<code>get_aq_from_xq(xq)</code>","text":"<p>Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3) The q-point in Cartesian coordinates / (2*pi).</p> required <p>Returns:</p> Type Description <p>ndarray(3) The q-point in fractional coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_aq_from_xq(self, xq: ArrayLike):\n    # sourcery skip: inline-immediately-returned-variable\n    \"\"\"\n    Get the q-point in fractional coordinates from a q-point in Cartesian coordinates / (2*pi).\n\n    Parameters:\n        - xq : ndarray(3)\n            The q-point in Cartesian coordinates / (2*pi).\n\n    Returns:\n        ndarray(3)\n            The q-point in fractional coordinates.\n    \"\"\"\n    return np.dot(xq, np.linalg.inv(self.bg.T))\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer._setup_lattice_symmetries","title":"<code>_setup_lattice_symmetries(verbose=False)</code>","text":"<p>Sets up the symmetries of the bravais lattice.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>bool Whether to print the number of symmetries of the bravais lattice.</p> <code>False</code> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def _setup_lattice_symmetries(self, verbose: bool = False):\n    \"\"\"\n    Sets up the symmetries of the bravais lattice.\n\n    Parameters:\n        verbose : bool\n            Whether to print the number of symmetries of the bravais lattice.\n    \"\"\"\n\n    # Sets up the symmetries of the bravais lattice\n    espresso_symm.symm_base.set_sym_bl(self.at)\n\n    # TODO: make these return values instead of modifying module vars\n    self.s = np.copy(espresso_symm.symm_base.s)\n    self.ft = np.copy(espresso_symm.symm_base.ft)\n    self.nrot = espresso_symm.symm_base.nrot\n\n    if verbose:\n        print(\"Symmetries of the bravais lattice:\", self.nrot)\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer._setup_crystal_symmetries","title":"<code>_setup_crystal_symmetries(verbose=False)</code>","text":"<p>Sets up the symmetries of the crystal.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>bool Whether to print the number of symmetries of the crystal.</p> <code>False</code> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def _setup_crystal_symmetries(self, verbose: bool = False):\n    \"\"\"\n    Sets up the symmetries of the crystal.\n\n    Parameters:\n        verbose : bool\n            Whether to print the number of symmetries of the crystal.\n    \"\"\"\n    # TODO: implement magnetism (currently just a dummy variable)\n    # TODO: some lines in symm_base need to be uncommented/checked\n    m_loc = np.zeros((3, self.nat), dtype=np.float64, order=\"F\")\n    nspin_mag = 1\n\n    # Find the symmetries of the crystal\n    espresso_symm.symm_base.set_sym(\n        self.at, self.bg, self.tau, self.ityp, nspin_mag, m_loc\n    )\n\n    # TODO: make these return values instead of modifying module vars\n    self.s = np.copy(espresso_symm.symm_base.s)\n    self.ft = np.copy(espresso_symm.symm_base.ft)\n    self.nsym = espresso_symm.symm_base.nsym\n    self.crystal_s = np.copy(self.s)\n    self.crystal_invs = np.copy(self.invs)\n    self.crystal_irt = np.copy(self.irt)\n\n    if verbose:\n        print(\"Symmetries of the crystal:\", self.nsym)\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer._setup_little_group","title":"<code>_setup_little_group(xq, verbose=False)</code>","text":"<p>Sets up the little group (small group) of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3), q point in CARTESIAN coordinates / (2 * pi)</p> required Source code in <code>quesadilla/symmetries.py</code> <pre><code>def _setup_little_group(self, xq: ArrayLike, verbose: bool = False):\n    \"\"\"\n    Sets up the little group (small group) of a q-point.\n\n    Parameters:\n        - xq : ndarray(3), q point in CARTESIAN coordinates / (2 * pi)\n    \"\"\"\n    # Set up the symmetries of the lattice\n    self._setup_lattice_symmetries(verbose)\n    # Set up the symmetries of the crystal\n    self._setup_crystal_symmetries(verbose)\n    # ~~~~~~~~~~PART 1~~~~~~~~~~\n    # Set up the symmetries of the small group of q\n    # ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    syms = np.zeros((48), dtype=np.intc)\n    syms[: self.nsym] = np.intc(1)\n\n    # TODO: make these return values instead of modifying module vars\n    espresso_symm.smallg_q(xq, 0, self.at, self.nsym, self.s, syms, self.minus_q)\n    # Copy the symmetries of the small group of q\n    self.nsymq = espresso_symm.symm_base.copy_sym(\n        espresso_symm.symm_base.nsym, syms\n    )\n    # Recompute the inverses as the order of sym.ops. has changed\n    espresso_symm.symm_base.inverse_s()\n    # Copy stuff into python\n    self.s = np.copy(espresso_symm.symm_base.s)\n    self.invs = np.copy(espresso_symm.symm_base.invs)\n    self.ft = np.copy(espresso_symm.symm_base.ft)\n    self.irt = np.copy(espresso_symm.symm_base.irt)\n\n    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    # PART 2: figure out the q -&gt; -q+G symmetries\n    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    lgamma = np.allclose(xq, [0, 0, 0], rtol=0, atol=1e-5)\n    self.irotmq, self.gi, self.gimq = espresso_symm.set_giq(\n        xq, lgamma, self.bg, self.at, self.s, self.nsymq, self.nsym, self.minus_q\n    )\n    # Part 3: Compute rtau = S . r_a - r_a\n    self.rtau = espresso_symm.sgam_lr(\n        self.at, self.bg, self.nsym, self.s, self.irt, self.tau\n    )\n\n    # Print some info\n    if verbose:\n        q = self.get_aq_from_xq(xq)\n        print(f\"Symmetries of the small group of q = {np.round(q, 5)}:\", self.nsymq)\n        if self.minus_q:\n            gimq = self.get_aq_from_xq(self.gimq)\n            print(\n                (\n                    f\"in addition sym. q -&gt; -q+G, with irotmq = {self.irotmq}\"\n                    f\" and G = {np.round(gimq, 3)}\"\n                )\n            )\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_star_q","title":"<code>get_star_q(xq, verbose=False, debug=False)</code>","text":"<p>Get the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>xq</code> <p>ndarray(3), q point in CARTESIAN coordinates / (2 * pi)</p> required <code>-</code> <code>verbose</code> <p>bool Whether to print the number of q-points in the star and the list of q-points in the star.</p> required <code>-</code> <code>debug</code> <p>bool Whether to print debug information from Fortran routines.</p> required <p>Returns:</p> Type Description <p>ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_star_q(self, xq: ArrayLike, verbose: bool = False, debug: bool = False):\n    # sourcery skip: extract-method\n    \"\"\"\n    Get the star of a q-point.\n\n    Parameters:\n        - xq : ndarray(3), q point in CARTESIAN coordinates / (2 * pi)\n        - verbose : bool\n            Whether to print the number of q-points in the star and the list of q-points in the star.\n        - debug : bool\n            Whether to print debug information from Fortran routines.\n\n    Returns:\n        ndarray(nq, 3), the q-points in the star in CARTESIAN coordinates / (2 * pi)\n    \"\"\"\n    # To get the star we need the symmetries of the WHOLE CRYSTAL\n    # So that's just the litle group of the Gamma point\n    self._setup_little_group(np.array([0, 0, 0]), verbose)\n    # Return values are:\n    # 1. number of q-points in the star\n    # 2. The vector that q is mapped to under each symmop\n    # 3. Index of q in sxq\n    # 4. Index of -q in sxq, 0 if not present\n    self.nqs, self.sxq, self.isq, self.imq = espresso_symm.star_q(\n        xq,  # q point in cartesian coordinates/2pi\n        self.at,  # lattice vectors (see __init__ for format)\n        self.bg,  # rec. lattice vectors (see __init__ for format)\n        self.nsym,  # Number of symmetries in the small group of q\n        self.s,  # Array of ALL symmetries of the crystal\n        self.invs,  # Index of inverse of s in self.s\n        False,  # Debug flag\n    )\n    star_xq = self.sxq[:, : self.nqs].T\n    if verbose:\n        q_star = np.array([self.get_aq_from_xq(xqs) for xqs in star_xq])\n        print(\"Number of q in the star:\", self.nqs)\n        print(\"List of q in the star:\")\n        for i, qq in enumerate(q_star):\n            print(f\"{i+1}    {np.round(qq, 8)}\")\n        if self.imq == 0:\n            print(\"In addition, there is the -q list, which is NOT in the star:\")\n            for i, qq in enumerate(q_star):\n                print(f\"{i+1+self.nqs}    {np.round(qq, 8)}\")\n        else:\n            mq = self.get_aq_from_xq(self.sxq[:, self.imq - 1])  # -q\n            gmq = self.get_aq_from_xq(self.gimq)  # G\n            q = self.get_aq_from_xq(xq)  # q\n            print(\"-q is also in the star: \", np.round(mq, 8))\n            print(\"With G = \", np.round(gmq, 8))\n            print(\"So that S_ @ q - (-q + G)\", np.round(mq + q - gmq, 5))\n\n    return star_xq\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.symmetrize_fcq","title":"<code>symmetrize_fcq(fcq, xq, verbose=False)</code>","text":"<p>Symmetrize the force constants at a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in CARTESIAN coordinates / (2 * pi)</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>(3 * nat, 3 * nat)</code> <p>The symmetrized force constants at q in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def symmetrize_fcq(self, fcq: ArrayLike, xq: ArrayLike, verbose: bool = False):\n    \"\"\"\n    Symmetrize the force constants at a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in CARTESIAN coordinates / (2 * pi)\n\n    Returns:\n        ndarray(3 * nat, 3* nat): The symmetrized force constants at q in FRACTIONAL coordinates.\n    \"\"\"\n    self._setup_little_group(xq, verbose)\n    return espresso_symm.symdynph_gq_new(\n        xq,\n        self.at,\n        self.bg,\n        fcq,\n        self.s,\n        self.invs,\n        self.rtau,\n        self.irt,\n        self.nsymq,\n        self.irotmq,\n        self.minus_q,\n    )\n</code></pre>"},{"location":"reference/quesadilla/symmetries/#quesadilla.symmetries.Symmetrizer.get_fcq_in_star","title":"<code>get_fcq_in_star(fcq, aq, verbose=True)</code>","text":"<p>Get the force constants in the star of a q-point.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fcq</code> <p>ndarray(3 * nat, 3 * nat), Fourier-transformed force constants         in FRACTIONAL coordinates</p> required <code>-</code> <code>q</code> <p>ndarray(3) The q vector, in FRACTIONAL coordinates</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3nat x 3nat matrix in FRACTIONAL coordinates.</p> Source code in <code>quesadilla/symmetries.py</code> <pre><code>def get_fcq_in_star(self, fcq, aq, verbose=True):\n    \"\"\"\n    Get the force constants in the star of a q-point.\n\n    Parameters:\n        - fcq : ndarray(3 * nat, 3 * nat), Fourier-transformed force constants\n                    in FRACTIONAL coordinates\n        - q : ndarray(3)\n            The q vector, in FRACTIONAL coordinates\n\n    Returns:\n        dict: The force constants in the star of q. Keys are the q-points in fractional coordinates. Values are the force constants in the star in the form of a 3*nat x 3*nat matrix in FRACTIONAL coordinates.\n    \"\"\"\n\n    # Symmetrize the force constants at q\n    aq = np.array(aq, dtype=np.float64, order=\"F\")\n    xq = self.get_xq_from_aq(aq)\n    fcq = np.array(fcq, dtype=np.complex128, order=\"F\")\n    fcq_symm = self.symmetrize_fcq(fcq, xq, verbose)\n\n    # Get star of the q-point\n    star_xq = self.get_star_q(xq, verbose)\n    # In the special case that -q is NOT in the star,\n    # We compute the FCQ at -q anyway using TRS and include it\n    if self.imq == 0:\n        nq_tot = 2 * self.nqs\n        star_xq = np.concatenate((star_xq, -star_xq), axis=0)\n    else:\n        nq_tot = self.nqs\n\n    # Get the FC(q) in the star\n    fcq_star = espresso_symm.q2qstar_ph(\n        fcq_symm,\n        self.at,\n        self.bg,\n        self.nsym,\n        self.s,\n        self.invs,\n        self.irt,\n        self.rtau,\n        self.nqs,\n        self.sxq,\n        self.isq,\n        self.imq,\n        nq_tot,\n    )\n\n    # Turn into a dictionary\n    final_fcq = {}\n    for i, xqq in enumerate(star_xq):\n        qq = self.get_aq_from_xq(xqq)\n        final_fcq[tuple(qq)] = fcq_star[i, :, :]\n\n    return final_fcq\n</code></pre>"},{"location":"reference/quesadilla/utils/","title":"utils","text":""},{"location":"reference/quesadilla/utils/#quesadilla.utils.write_lwm","title":"<code>write_lwm(prim, grid, path)</code>","text":"<p>Writes the lattice matrix, irreducible q-points, and grid to files suitable for input to Lloyd-Williams and Monserrat's code.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <code>Structure</code> <p>The primitive structure.</p> required <code>grid</code> <code>list</code> <p>The grid of q-points.</p> required <code>path</code> <code>str</code> <p>The directory to write the files to.</p> required Source code in <code>quesadilla/utils.py</code> <pre><code>def write_lwm(prim, grid, path):\n    \"\"\"\n    Writes the lattice matrix, irreducible q-points, and grid to files\n    suitable for input to Lloyd-Williams and Monserrat's code.\n\n    Args:\n        prim (pymatgen.Structure): The primitive structure.\n        grid (list): The grid of q-points.\n        path (str): The directory to write the files to.\n    \"\"\"\n    sga = SpacegroupAnalyzer(prim)\n    q_irr = sga.get_ir_reciprocal_mesh(grid)\n    q_irr = np.array([q[0] for q in q_irr])\n    # Write lattice matrix to path/prim.dat\n    np.savetxt(f\"{path}/prim.dat\", prim.lattice.matrix, fmt=\"%.10f\")\n    # Write irreducible q-points to path/ibz.dat\n    np.savetxt(f\"{path}/ibz.dat\", q_irr, fmt=\"%.10f\")\n    # Write grid to path/grid.dat\n    np.savetxt(f\"{path}/grid.dat\", np.array(grid), fmt=\"%d\", newline=\" \")\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.read_lwm","title":"<code>read_lwm(path)</code>","text":"<p>Reads kpoint_to_supercell.dat and associated supercell files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the directory containing kpoint_to_supercell.dat and supercell..dat files. required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def read_lwm(path):\n    \"\"\"\n    Reads kpoint_to_supercell.dat and associated supercell files.\n\n    Args:\n        path (str): Path to the directory containing kpoint_to_supercell.dat and supercell.&lt;i&gt;.dat files.\n\n    Returns:\n        tuple: A NumPy array of vectors (n x 3) and a list of associated matrices (each 3 x 3).\n    \"\"\"\n    # File paths\n    kpoint_file = os.path.join(path, \"kpoint_to_supercell.dat\")\n\n    # Read kpoint_to_supercell.dat using NumPy\n    kpoint_data = np.loadtxt(kpoint_file)\n\n    # Extract vectors (first 3 columns) and indices (last column)\n    q = kpoint_data[:, :3]\n    indices = kpoint_data[:, 3].astype(int)\n\n    # Read the associated supercell matrices\n    matrices = []\n    for i in indices:\n        supercell_file = os.path.join(path, f\"supercell.{i}.dat\")\n        T = np.loadtxt(supercell_file, dtype=int)  # Read the 3x3 matrix\n        matrices.append(make_positive_det(T))\n        # for qq in q:\n        qq = q[i - 1]\n        assert np.allclose(\n            T @ qq, np.round(T @ qq)\n        ), \"Supercell {i} is not commensurate with q = {qq}\"\n\n    return np.array(matrices), np.array(q)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.get_KPOINTS","title":"<code>get_KPOINTS(struct, kspace)</code>","text":"<p>TODO: switch to autoGR Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5. Parameters:</p> <p>struct : pymatgen.Structure     The structure object. kspace : float     The spacing of the k-point mesh in 1/\u00c5. Returns:</p> <p>kpoints : pymatgen.io.vasp.inputs.Kpoints     The KPOINTS object.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def get_KPOINTS(struct, kspace):\n    \"\"\"\n    TODO: switch to autoGR\n    Prepares a KPOINTS object with a mesh of given spacing in 1/\u00c5.\n    Parameters:\n    -----------\n    struct : pymatgen.Structure\n        The structure object.\n    kspace : float\n        The spacing of the k-point mesh in 1/\u00c5.\n    Returns:\n    --------\n    kpoints : pymatgen.io.vasp.inputs.Kpoints\n        The KPOINTS object.\n    \"\"\"\n    assert kspace &gt; 0, \"argument kspace must not be negative\"\n    b = np.array(struct.lattice.reciprocal_lattice.matrix)\n    N = np.maximum(\n        np.array([1, 1, 1]), np.round(np.sqrt(np.sum(b**2, axis=1)) / kspace)\n    ).astype(np.int64)\n    k_dict = {\n        \"nkpoints\": 0,\n        \"generation_style\": \"Gamma\",\n        \"kpoints\": [[N[0], N[1], N[2]]],\n        \"usershift\": [0, 0, 0],\n        \"comment\": f\"Mesh with spacing {kspace} 1/\u00c5\",\n    }\n    return Kpoints.from_dict(k_dict)\n</code></pre>"},{"location":"reference/quesadilla/utils/#quesadilla.utils.generate_files","title":"<code>generate_files(primitive_filename, grid, k_spacing=0.15, verbose=False)</code>","text":"<p>Generates the files for an NDSC phonon calculation.</p> Source code in <code>quesadilla/utils.py</code> <pre><code>def generate_files(\n    primitive_filename: str, grid: list, k_spacing: float = 0.15, verbose: bool = False\n):\n    \"\"\"\n    Generates the files for an NDSC phonon calculation.\n    \"\"\"\n\n    root = os.path.dirname(primitive_filename)\n    primitive = get_phonopy_prim(primitive_filename)\n    sc_gen = SupercellGenerator(primitive, grid)\n    sc_gen.generate_supercells()\n\n    # pymatgen structure object\n    new_prim_filename = os.path.join(root, \"POSCAR_standard_primitive\")\n    prim = Structure.from_file(new_prim_filename)\n\n    T_matrices, sc_size, comm_q = sc_gen.sc_matrices, sc_gen.sc_sizes, sc_gen.q_comm\n    for i, (T, sz, q) in enumerate(zip(T_matrices, sc_size, comm_q)):\n        # Print the supercell information\n        if verbose:\n            print(\n                (\n                    f\"Supercell {i+1} with size {sz} is commensurate with q = \"\n                    f\"{np.round(q, 3)}\"\n                )\n            )\n            print(\"Supercell matrix:\")\n            print(T)\n        # Generate the supercell\n        sc_path = os.path.join(root, f\"sc-{i+1}\")\n        os.makedirs(sc_path, exist_ok=True)\n        sc = prim.copy()\n        sc.make_supercell(T)\n        prim.to(filename=os.path.join(sc_path, \"POSCAR\"), fmt=\"poscar\")\n        sc.to(filename=os.path.join(sc_path, \"quesadilla_ndsc.vasp\"), fmt=\"poscar\")\n        get_KPOINTS(sc, k_spacing).write_file(os.path.join(sc_path, \"KPOINTS\"))\n\n        # DIM string uses supercell matrix, flattened. Phonopy uses transpose\n        T_str = \" \".join([f\"{int(x):d}\" for x in T.T.flatten()])\n        with open(os.path.join(sc_path, \"make_disp.conf\"), \"w\") as f:\n            f.write(MAKE_DISP.format(T_str))\n        with open(os.path.join(sc_path, \"get_yaml.conf\"), \"w\") as f:\n            f.write(GET_YAML.format(T_str))\n    sc_gen.to_toml(os.path.join(root, \"quesadilla.toml\"))\n</code></pre>"},{"location":"reference/tools/run_f2py/","title":"run_f2py","text":""}]}