import itertools
import os
from pathlib import Path

import numpy as np
import phonopy
from numpy.typing import ArrayLike
from phonopy import Phonopy
from phonopy.harmonic.dynmat_to_fc import (
    DynmatToForceConstants,
)

import quesadilla.symmetries as symmetries
from quesadilla.supercells import SupercellGenerator, struct_to_phonopy


class NondiagonalPhononCalculator:
    def __init__(self, root: Path):
        self.root = root
        self.sc_gen = SupercellGenerator.from_toml(
            os.path.join(root, "quesadilla.toml")
        )
        self._parse_ndsc_phonons()

    def run(self, verbose: bool = False):
        # Get fourier transformered FCs in IBZ
        irr_dynmat = self._get_dynmat_in_ibz()
        irr_fcq = {q: self._dynmat_to_fcq(dyn, q) for q, dyn in irr_dynmat.items()}

        ## Unfold the FCs to the full star of each q point
        full_fcq = {}
        symmetrizer = symmetries.Symmetrizer(self.sc_gen.primitive)
        for q, D in irr_fcq.items():
            full_fcq |= symmetrizer.get_fcq_in_star(D, q, verbose=verbose)

        self.phonons = self._get_phonopy_from_fcq(full_fcq)

    def _parse_ndsc_phonons(self) -> list[Phonopy]:
        """
        Reads the phonopy.yaml files from the supercells generated by Quesadilla

        Args:
            root: Path to the directory containing the supercells
            sc_gen: SupercellGenerator object
        """
        n_sc = len([d for d in os.listdir(self.root) if d.startswith("sc-")])
        assert n_sc == len(
            self.sc_gen.sc_matrices
        ), "Number of supercells does not match"
        phonons = [
            phonopy.load(
                os.path.join(self.root, f"sc-{i+1}", "phonopy.yaml"),
                is_symmetry=False,
                symmetrize_fc=False,
            )
            for i in range(n_sc)
        ]
        # Now assert that the supercell matrices are the same
        for i, (p, T) in enumerate(zip(phonons, self.sc_gen.sc_matrices)):
            assert np.all(
                p.supercell_matrix.T == T
            ), f"{i+1}: Supercell matrices do not match, {p.supercell_matrix.T} vs {T}"

        self.nd_phonons = phonons

    def _get_dynmat_in_ibz(
        self,
        average_gamma: bool = False,
        average_non_gamma: bool = False,
    ) -> dict[tuple[float, float, float], np.ndarray]:
        """
        Gets the Fourier transformed force constant matrices
        TODO: should take a list of force constants not path to the files!
        """
        dynmats = {}
        for i, p in enumerate(self.nd_phonons):
            q = self.sc_gen.q_comm[i][0]
            T = p.supercell_matrix
            assert np.allclose(T.T @ q, (T.T @ q).astype(int)), "q is not commensurate?"
            p.dynamical_matrix.run(q)
            dynmats.setdefault(tuple(q), []).append(p.dynamical_matrix.dynamical_matrix)

        for q, dyn_mats in dynmats.items():
            print(f"Found {len(dyn_mats)} dynamical matrices at q = {q}")
            if q == (0, 0, 0):
                dynmats[q] = np.mean(dyn_mats, axis=0) if average_gamma else dyn_mats[0]
            elif len(dyn_mats) > 1:
                dynmats[q] = (
                    np.mean(dyn_mats, axis=0) if average_non_gamma else dyn_mats[0]
                )
            else:
                dynmats[q] = dyn_mats[0]

        return dynmats

    def _get_phonopy_from_fcq(
        self, full_fcq: dict[tuple[float, float, float], np.ndarray]
    ) -> Phonopy:
        """
        Create a Phonopy object from the full force constant matrix.

        Args:
            sc_gen: SupercellGenerator object
            full_fcq: The full force constant matrix
        """
        primitive, supercell = struct_to_phonopy(
            self.sc_gen.primitive, self.sc_gen.grid
        )
        print("Creating the Phonopy object...")
        nd_phonon = Phonopy(primitive, supercell_matrix=np.diag(self.sc_gen.grid))
        print("Fourier transforming the force constants back to real space...")
        nd_phonon.force_constants = self._fcq_to_fcr(
            full_fcq,
        )
        print("Applying acoustic sum rules...")
        nd_phonon.symmetrize_force_constants()
        return nd_phonon

    def _fcq_to_fcr(
        self, fcq: dict[tuple[float, float, float], np.ndarray]
    ) -> np.ndarray:
        """
        Fourier transform the force constants on the full q-grid to real
        space.
        """
        primitive, supercell = struct_to_phonopy(
            self.sc_gen.primitive, self.sc_gen.grid
        )
        all_q = np.array(list(fcq.keys()))
        print(f"Found {len(all_q)} q-points in the full BZ")
        dynmat = np.array([self._fcq_to_dynmat(fcq[tuple(q)], q) for q in all_q])
        d2f = DynmatToForceConstants(
            primitive,
            supercell,
            is_full_fc=True,
        )
        d2f.commensurate_points = all_q
        d2f.dynamical_matrices = dynmat
        print("Running DynmatToForceConstants...")
        d2f.run()
        return d2f.force_constants

    def _dynmat_to_fcq(self, D: np.ndarray, q: ArrayLike) -> np.ndarray:
        """
        Converts the dynamical matrix as defined by phonopy into
        the Fourier transformer force constant matrix as defined
        by Quantum ESPRESSO and read by Quesadilla's symmetry routines.

        Args:
            prim: The primitive structure
            D: The dynamical matrix (3*nat x 3*nat)
            q: The q-point in FRAC coords

        Returns:
            The Fourier transformed force constant matrix (3*nat x 3*nat)
        """
        N = len(self.sc_gen.primitive)
        masses = np.array(
            [s.species.elements[0].atomic_mass for s in self.sc_gen.primitive]
        )
        D_blocks = D.reshape(N, 3, N, 3).swapaxes(1, 2)
        for i, j in itertools.product(range(N), range(N)):
            r_i = self.sc_gen.primitive[i].frac_coords
            r_j = self.sc_gen.primitive[j].frac_coords
            D_blocks[i, j] *= (
                np.exp(1j * 2 * np.pi * np.dot(q, r_i))
                * np.exp(-1j * 2 * np.pi * np.dot(q, r_j))
                * np.sqrt(masses[i] * masses[j])
            )
        return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)

    def _fcq_to_dynmat(self, fcq: np.ndarray, q: np.ndarray):
        """
        Converts the Fourier transformed force constant matrix as defined
        by Quantum ESPRESSO and produced by Quesadilla's symmetry routines into
        the dynamical matrix as defined by phonopy.

        Args:
            prim: The primitive structure
            fcq: The Fourier transformed force constant matrix (3*nat x 3*nat)
            q: The q-point in FRAC coords

        Returns:
            The dynamical matrix (3*nat x 3*nat)
        """
        N = len(self.sc_gen.primitive)
        masses = np.array(
            [s.species.elements[0].atomic_mass for s in self.sc_gen.primitive]
        )
        D_blocks = fcq.reshape(N, 3, N, 3).swapaxes(1, 2)
        for i, j in itertools.product(range(N), range(N)):
            r_i = self.sc_gen.primitive[i].frac_coords
            r_j = self.sc_gen.primitive[j].frac_coords
            D_blocks[i, j] *= (
                np.exp(-1j * 2 * np.pi * np.dot(q, r_i))
                * np.exp(1j * 2 * np.pi * np.dot(q, r_j))
                / np.sqrt(masses[i] * masses[j])
            )
        return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)
