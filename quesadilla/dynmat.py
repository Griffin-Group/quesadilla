import itertools
import os
from pathlib import Path

import numpy as np
import phonopy
from numpy.typing import ArrayLike
from phonopy import Phonopy
from phonopy.harmonic.dynmat_to_fc import (
    DynmatToForceConstants,
)
from pymatgen.core.structure import Structure

import quesadilla.symmetries as symmetries
from quesadilla.supercells import SupercellGenerator, struct_to_phonopy


def get_nd_phonopy(root: Path, verbose: bool = False) -> Phonopy:
    sc_gen = SupercellGenerator.from_toml(os.path.join(root, "quesadilla.toml"))
    nd_phonons = read_nd_phonopy_yaml(root, sc_gen)

    # Get fourier transformered FCs in IBZ
    irr_dynmat = get_dynmat_ibz(nd_phonons, sc_gen.q_comm)
    irr_fcq = {
        q: dynmat_to_fcq(sc_gen.primitive, dyn, q) for q, dyn in irr_dynmat.items()
    }

    # Unfold the FCs to the full star
    full_fcq = {}
    symmetrizer = symmetries.Symmetrizer(sc_gen.primitive)
    for q, D in irr_fcq.items():
        full_fcq |= symmetrizer.get_fcq_in_star(D, q, verbose=verbose)

    return get_phonopy_from_fcq(sc_gen, full_fcq)


def get_phonopy_from_fcq(
    sc_gen: Structure, full_fcq: dict[tuple[float, float, float], np.ndarray]
) -> Phonopy:
    """
    Create a Phonopy object from the full force constant matrix.

    Args:
        sc_gen: SupercellGenerator object
        full_fcq: The full force constant matrix
    """
    primitive, supercell = struct_to_phonopy(sc_gen.primitive, sc_gen.grid)
    print("Creating the Phonopy object...")
    nd_phonon = Phonopy(primitive, supercell_matrix=np.diag(sc_gen.grid))
    print("Fourier transforming the force constants back to real space...")
    nd_phonon.force_constants = fcq_to_fcr(full_fcq, sc_gen.primitive, sc_gen.grid)
    print("Applying acoustic sum rules...")
    nd_phonon.symmetrize_force_constants()
    return nd_phonon


def read_nd_phonopy_yaml(root: Path, sc_gen: SupercellGenerator) -> list[Phonopy]:
    """
    Reads the phonopy.yaml files from the supercells generated by Quesadilla

    Args:
        root: Path to the directory containing the supercells
        sc_gen: SupercellGenerator object
    """
    n_sc = len([d for d in os.listdir(root) if d.startswith("sc-")])
    assert n_sc == len(sc_gen.sc_matrices), "Number of supercells does not match"
    phonons = [
        phonopy.load(
            os.path.join(root, f"sc-{i+1}", "phonopy.yaml"),
            is_symmetry=False,
            symmetrize_fc=False,
        )
        for i in range(n_sc)
    ]
    # Now assert that the supercell matrices are the same
    for p, T in zip(phonons, sc_gen.sc_matrices):
        assert np.all(p.supercell_matrix.T == T), "Supercell matrices do not match"

    return phonons


def get_dynmat_ibz(
    phonons: list[Phonopy],
    q_comm: np.ndarray,
    average_gamma: bool = False,
    average_non_gamma: bool = False,
) -> dict[tuple[float, float, float], np.ndarray]:
    """
    Gets the Fourier transformed force constant matrices
    TODO: should take a list of force constants not path to the files!
    """
    dynmats = {}
    for i, p in enumerate(phonons):
        q = q_comm[i][0]
        T = p.supercell_matrix
        assert np.allclose(T.T @ q, (T.T @ q).astype(int)), "q is not commensurate?"
        p.dynamical_matrix.run(q)
        dynmats.setdefault(tuple(q), []).append(p.dynamical_matrix.dynamical_matrix)

    for q, dyn_mats in dynmats.items():
        print(f"Found {len(dyn_mats)} dynamical matrices at q = {q}")
        if q == (0, 0, 0):
            dynmats[q] = np.mean(dyn_mats, axis=0) if average_gamma else dyn_mats[0]
        elif len(dyn_mats) > 1:
            dynmats[q] = np.mean(dyn_mats, axis=0) if average_non_gamma else dyn_mats[0]
        else:
            dynmats[q] = dyn_mats[0]

    return dynmats


def fcq_to_fcr(fcq, prim, grid):
    """
    Fourier transform the force constants on the full q-grid to real
    space.
    """
    primitive, supercell = struct_to_phonopy(prim, grid)
    all_q = np.array(list(fcq.keys()))
    print(f"Found {len(all_q)} q-points in the full BZ")
    dynmat = np.array([fcq_to_dynmat(prim, fcq[tuple(q)], q) for q in all_q])
    d2f = DynmatToForceConstants(
        primitive,
        supercell,
        is_full_fc=True,
    )
    d2f.commensurate_points = all_q
    d2f.dynamical_matrices = dynmat
    print("Running DynmatToForceConstants...")
    d2f.run()
    return d2f.force_constants


def dynmat_to_fcq(prim: Structure, D: np.ndarray, q: ArrayLike) -> np.ndarray:
    """
    Converts the dynamical matrix as defined by phonopy into
    the Fourier transformer force constant matrix as defined
    by Quantum ESPRESSO and read by Quesadilla's symmetry routines.

    Args:
        prim: The primitive structure
        D: The dynamical matrix (3*nat x 3*nat)
        q: The q-point in FRAC coords

    Returns:
        The Fourier transformed force constant matrix (3*nat x 3*nat)
    """
    N = len(prim)
    masses = np.array([s.species.elements[0].atomic_mass for s in prim])
    D_blocks = D.reshape(N, 3, N, 3).swapaxes(1, 2)
    for i, j in itertools.product(range(N), range(N)):
        r_i = prim[i].frac_coords
        r_j = prim[j].frac_coords
        D_blocks[i, j] *= (
            np.exp(1j * 2 * np.pi * np.dot(q, r_i))
            * np.exp(-1j * 2 * np.pi * np.dot(q, r_j))
            * np.sqrt(masses[i] * masses[j])
        )
    return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)


def fcq_to_dynmat(prim, fcq, q):
    """
    Converts the Fourier transformed force constant matrix as defined
    by Quantum ESPRESSO and produced by Quesadilla's symmetry routines into
    the dynamical matrix as defined by phonopy.

    Args:
        prim: The primitive structure
        fcq: The Fourier transformed force constant matrix (3*nat x 3*nat)
        q: The q-point in FRAC coords

    Returns:
        The dynamical matrix (3*nat x 3*nat)
    """
    N = len(prim)
    masses = np.array([s.species.elements[0].atomic_mass for s in prim])
    D_blocks = fcq.reshape(N, 3, N, 3).swapaxes(1, 2)
    for i, j in itertools.product(range(N), range(N)):
        r_i = prim[i].frac_coords
        r_j = prim[j].frac_coords
        D_blocks[i, j] *= (
            np.exp(-1j * 2 * np.pi * np.dot(q, r_i))
            * np.exp(1j * 2 * np.pi * np.dot(q, r_j))
            / np.sqrt(masses[i] * masses[j])
        )
    return D_blocks.swapaxes(1, 2).reshape(3 * N, 3 * N)
